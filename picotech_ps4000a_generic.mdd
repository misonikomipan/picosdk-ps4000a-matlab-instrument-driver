<?xml version="1.0" encoding="utf-8"?>
<MATLABInstrumentDriver>
   <FileVersion>2.42</FileVersion>
   <DriverName>picotech_ps4000a_generic.mdd</DriverName>
   <DriverType>MATLAB generic</DriverType>
   <InstrumentType>Oscilloscope</InstrumentType>
   <InstrumentManufacturer>Pico Technology Ltd.</InstrumentManufacturer>
   <InstrumentModel>PicoScope 4000 Series (A API)</InstrumentModel>
   <InstrumentVersion>1.2.16.10</InstrumentVersion>
   <Identify/>
   <Reset/>
   <Selftest/>
   <Error/>
   <CreateInitCode>
      <Code>function init(obj)
% This function is called after the object is created.
% OBJ is the device object.
% End of function definition - DO NOT EDIT

% Copyright © 2014-2019 Pico Technology Ltd. All rights reserved. 
% You may copy and distribute this file as long as it remains unmodified. 
% SB
    
    fprintf('\nPicoScope 4000 Series (A API) MATLAB Instrument Driver\n');
    fprintf('\n');
    fprintf('Copyright © 2014-2019 Pico Technology Ltd. All rights reserved.\n');
    fprintf('\n');
    
    % Load libraries
    % ==============
    
    % Indentify architecture and obtain function handle for the correct
    % prototype file.
    
    archStr = computer('arch');
    
    ps4000aMFile = str2func(strcat('ps4000aMFile_', archStr));
    ps4000aWrapMFile = str2func(strcat('ps4000aWrapMFile_', archStr));
    
    % ps4000aWrapMFile_archStr.m contains duplicate enumerations and
    % structures from ps4000aMFile_archStr.m
    
    warning('off','MATLAB:loadlibrary:EnumExists');
    warning('off','MATLAB:loadlibrary:StructTypeExists');
    
    % Only load library once 
    if (libisloaded('ps4000a'))
       
        % Do nothing
        
    else
        
        if (ismac())
            
            [ps4000aNotFound, ps4000aWarnings] = loadlibrary('libps4000a.dylib', ps4000aMFile, 'alias', 'ps4000a');
        
        elseif (isunix())
            
            [ps4000aNotFound, ps4000aWarnings] = loadlibrary('libps4000a.so', ps4000aMFile, 'alias', 'ps4000a');
            
        elseif (ispc())
            
            [ps4000aNotFound, ps4000aWarnings] = loadlibrary('ps4000a.dll', ps4000aMFile);
                
        else
            
            % Do nothing
                
        end     
        
    end
    
    % Only load library once 
    if (libisloaded('ps4000aWrap'))

        % Do nothing
        
    else
        
        if (ismac())
            
            [ps4000aWrapNotFound, ps4000aWrapWarnings] = loadlibrary('libps4000aWrap.dylib', ps4000aWrapMFile, 'alias', 'ps4000aWrap');
    
        elseif (isunix())
            
            [ps4000aWrapNotFound, ps4000aWrapWarnings] = loadlibrary('libps4000aWrap.so', ps4000aWrapMFile, 'alias', 'ps4000aWrap');
                
        elseif (ispc())
            
            [ps4000aWrapNotFound, ps4000aWrapWarnings] = loadlibrary('ps4000aWrap.dll', ps4000aWrapMFile);
        
        else
            
            % Do nothing
                
        end  
        
    end
    
    % Load in enumeration and structure information
    % =============================================
    
    [~, obj.DriverData.structs, obj.DriverData.enums, ~] = ps4000aMFile(); 
    
    % Define constant values used by this Instrument Driver
    % =====================================================
    
    % Constants from ps4000aApi.h header file
    % ---------------------------------------
    
    % ADC Count Properties
        
    obj.DriverData.constants.PS4000A_MAX_VALUE                  = 32767;    % ADC Counts
    obj.DriverData.constants.PS4000A_MIN_VALUE                  = -32767;   % ADC Counts

    % External trigger: Max/min counts

    obj.DriverData.constants.PS4000A_EXT_MAX_VALUE              = 32767;    % Counts
    obj.DriverData.constants.PS4000A_EXT_MIN_VALUE              = -32767;   % Counts

    % Trigger Properties

    obj.DriverData.constants.MAX_PULSE_WIDTH_QUALIFIER_COUNT    = 16777215;
    obj.DriverData.constants.MAX_DELAY_COUNT                    = 8388607;

    % Analogue offset values (Volts)

    obj.DriverData.constants.PS4000A_MAX_ANALOGUE_OFFSET_50MV_200MV  = 0.250;
    obj.DriverData.constants.PS4000A_MIN_ANALOGUE_OFFSET_50MV_200MV  = -0.250;
    obj.DriverData.constants.PS4000A_MAX_ANALOGUE_OFFSET_500MV_2V    = 2.500;
    obj.DriverData.constants.PS4000A_MIN_ANALOGUE_OFFSET_500MV_2V    = -2.500;
    obj.DriverData.constants.PS4000A_MAX_ANALOGUE_OFFSET_5V_20V      = 20;
    obj.DriverData.constants.PS4000A_MIN_ANALOGUE_OFFSET_5V_20V      = -20;

    % Function/Arbitrary Waveform Parameters

    obj.DriverData.constants.PS4000A_MAX_SIG_GEN_BUFFER_SIZE    = 16384;   
    obj.DriverData.constants.PS4000A_MIN_SIG_GEN_BUFFER_SIZE    = 10;
    obj.DriverData.constants.PS4000A_MIN_DWELL_COUNT            = 10;
    obj.DriverData.constants.PS4000A_MAX_SWEEPS_SHOTS           = pow2(30) - 1; % 1073741823

    % Maximum/Minimum Waveform Frequencies (in Hertz)

    obj.DriverData.constants.PS4000A_SINE_MAX_FREQUENCY         = 1000000;
    obj.DriverData.constants.PS4000A_SQUARE_MAX_FREQUENCY       = 1000000;
    obj.DriverData.constants.PS4000A_TRIANGLE_MAX_FREQUENCY     = 1000000;
    obj.DriverData.constants.PS4000A_SINC_MAX_FREQUENCY         = 1000000
    obj.DriverData.constants.PS4000A_RAMP_MAX_FREQUENCY         = 1000000;
    obj.DriverData.constants.PS4000A_HALF_SINE_MAX_FREQUENCY	= 1000000;
    obj.DriverData.constants.PS4000A_GAUSSIAN_MAX_FREQUENCY     = 1000000;
    obj.DriverData.constants.PS4000A_MIN_FREQUENCY              = 0.03;
    
    % Intelligent probe ranges
    
    obj.DriverData.constants.PICO_CONNECT_PROBE_CURRENT_CLAMP_200_2KA_RANGES = [1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000];
	obj.DriverData.constants.PICO_CONNECT_PROBE_CURRENT_CLAMP_40A_RANGES = [0.1, 0.2, 0.5, 1, 2, 5, 10, 20, 40];
	obj.DriverData.constants.PICO_CONNECT_PROBE_CAT3_HV_1KV_RANGES = [2.5, 5, 12.5, 25, 50, 125, 250, 500, 1000];
	obj.DriverData.constants.PICO_CONNECT_PROBE_CURRENT_CLAMP_2000ARMS_RANGES = [10, 20, 50, 100, 200, 500, 1000, 2000, 5000];

    % Maximum number of devices using this driver
    % -------------------------------------------
    
    obj.DriverData.constants.PS4000A_MAX_UNITS = 64;
    
    % PicoScope 4000 Series Models (using the ps4000a driver API functions)

    obj.DriverData.variants.MODEL_NONE      = 'NONE';

    % Variants that can be used
    obj.DriverData.variants.MODEL_PS4225   = '4225';
    obj.DriverData.variants.MODEL_PS4425   = '4425';
    obj.DriverData.variants.MODEL_PS4444   = '4444';
    obj.DriverData.variants.MODEL_PS4824   = '4824';
    obj.DriverData.variants.MODEL_PS4225A   = '4225A';
    obj.DriverData.variants.MODEL_PS4425A   = '4425A';
    obj.DriverData.variants.MODEL_PS4224A   = '4224A';
    obj.DriverData.variants.MODEL_PS4424A   = '4424A';
    obj.DriverData.variants.MODEL_PS4824A   = '4824A';
    obj.DriverData.variants.MODEL_PS4823   = '4823';
    
    % Obtain flag to indicate if functions should output text to Command
    % Window
    % -------------------------------
    
    obj.DriverData.displayOutput = obj.displayOutput;
    
    % Enumerate units 
    % ---------------
    
    % Only displayed if driver is being used via command line
    
    count = int16(0);
    serialLth = int16(100);
    serials = blanks(serialLth);
    
    [status, count, serials, serialLth] = calllib('ps4000a', ...
        'ps4000aEnumerateUnits', count, serials, serialLth);
    
    if (status == PicoStatus.PICO_OK)
        
        fprintf('Number of units found: %d\n\nSerial number(s): %s\n\n', count, serials);
        
    elseif (status == PicoStatus.PICO_NOT_FOUND)
        
        error('No devices found.');
        
    else
        
        error('Status code: %d. Please refer to the PicoStatus.m file.\n', status);
        
    end
    </Code>
   </CreateInitCode>
   <ConnectInitCode>
      <Type>MCode</Type>
      <Code>function init(obj)
% This function is called after the object is connected.
% OBJ is the device object.
% End of function definition - DO NOT EDIT

% Copyright (C) 2014-2019 Pico Technology Ltd. All rights reserved. 
% You may copy and distribute this file as long as it remains unmodified.

    disp('Opening PicoScope 4000 Series (A API) device...');

    % Structure to hold status values while connecting to the device.
    % Only output when the driver is called using command line or script.
    connectStatus = [];

    % Temporary variable to store handle value
    unitHandle = 0;
    
    % PICO_OK status value (0)
    picoOK = PicoStatus.PICO_OK;

    % Obtain the serial input
    serialNum = get(obj, 'RsrcName');

    % Determine if serial number is specified or null
    if length(serialNum) &gt; 0

        unitSerial = serialNum;

    else

        unitSerial = [];

    end

    % Open the unit
    [connectStatus.openUnit, unitHandle] = ...
        calllib('ps4000a', 'ps4000aOpenUnit', unitHandle, unitSerial);

    obj.DriverData.unitHandle = unitHandle;
    
    % Check Power Settings

    powerStatus = 0;
    
    % Initial channel settings to assist with change in power source
    % Setup initial channel settings (8 x 4)
    % 8 channels consisting of enabled, coupling, range, analogue offset
    % Default will be set later via resetDevice
    
    obj.DriverData.channelSettings = zeros(PicoConstants.OCTO_SCOPE, 4);

    % If connected to a non-USB 3.0 port or power supply is not connected, 
    % change the power source
    if (connectStatus.openUnit == PicoStatus.PICO_USB3_0_DEVICE_NON_USB3_0_PORT || ...
            connectStatus.openUnit == PicoStatus.PICO_POWER_SUPPLY_NOT_CONNECTED) 

        powerStatus = invoke(obj, 'ps4000aChangePowerSource', ...
            connectStatus.openUnit);
    
    end

    % Set handle and serial 
    % Unit connected if 0 or power supply not connected
    if (connectStatus.openUnit == picoOK || powerStatus == picoOK)

        % Display object information
        obj
        
        unitHandle = obj.DriverData.unitHandle;

        infoLine = blanks(40);
        reqSize = 40;

        [connectStatus.unitSerial, unitSerial, reqSize]  = calllib('ps4000a', ...
                'ps4000aGetUnitInfo', unitHandle, infoLine, ... 
                length(infoLine), reqSize, PicoStatus.PICO_BATCH_AND_SERIAL);

        obj.DriverData.unitSerial = unitSerial;

        % Set variant and channel count information

        infoLineV = blanks(40);
        reqSizeV = 40;
        
        [connectStatus.unitVariant, variant, reqSizeV]  = calllib('ps4000a', ...
                'ps4000aGetUnitInfo', unitHandle, infoLineV, ... 
                length(infoLineV), reqSizeV, PicoStatus.PICO_VARIANT_INFO);

        set(obj, 'InstrumentModel', variant);
        
        % Set Device Properties
        % ---------------------
        
        range10mV = obj.DriverData.enums.enPicoConnectProbeRange.PICO_X1_PROBE_10MV;
        range20mV = obj.DriverData.enums.enPicoConnectProbeRange.PICO_X1_PROBE_20MV;
        range50mV = obj.DriverData.enums.enPicoConnectProbeRange.PICO_X1_PROBE_50MV;
        range50V  = obj.DriverData.enums.enPicoConnectProbeRange.PICO_X1_PROBE_50V;
        range200V = obj.DriverData.enums.enPicoConnectProbeRange.PICO_X1_PROBE_200V;
        
        % Obtain channel count
        obj.DriverData.channelCount = str2num(obj.InstrumentModel(2));
        
        % Inform the wrapper dll of the number of channels on the device
        status = calllib('ps4000aWrap', 'setChannelCount', obj.DriverData.unitHandle, ...
                            obj.DriverData.channelCount);
        
        % Set device parameters
        switch (obj.InstrumentModel)

            case obj.DriverData.variants.MODEL_PS4225

                obj.DriverData.channelCount = PicoConstants.DUAL_SCOPE;
                obj.DriverData.firstRange = range50mV;
                obj.DriverData.lastRange = range200V;
                obj.DriverData.hasHardwareEts = PicoConstants.FALSE;
                obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_250MS;
                obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_20MHZ;
                obj.DriverData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_400MSPS;
                obj.DriverData.isFlexResDevice = PicoConstants.FALSE;
                obj.DriverData.hasIntelligentProbeInterface = PicoConstants.FALSE;

            case obj.DriverData.variants.MODEL_PS4425

                obj.DriverData.channelCount = PicoConstants.QUAD_SCOPE;
                obj.DriverData.firstRange = range50mV;
                obj.DriverData.lastRange = range200V;
                obj.DriverData.hasHardwareEts = PicoConstants.FALSE;
                obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_250MS;
                obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_20MHZ;
                obj.DriverData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_400MSPS;
                obj.DriverData.isFlexResDevice = PicoConstants.FALSE;
                obj.DriverData.hasIntelligentProbeInterface = PicoConstants.FALSE;

            case obj.DriverData.variants.MODEL_PS4444

                obj.DriverData.channelCount = PicoConstants.QUAD_SCOPE;
                obj.DriverData.firstRange = range50mV;
                obj.DriverData.lastRange = range200V;
                obj.DriverData.hasHardwareEts = PicoConstants.FALSE;
                obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_256MS;
                obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_20MHZ;
                obj.DriverData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_400MSPS;
                obj.DriverData.isFlexResDevice = PicoConstants.TRUE;
                obj.DriverData.hasIntelligentProbeInterface = PicoConstants.TRUE;
                
            case obj.DriverData.variants.MODEL_PS4824

                obj.DriverData.channelCount = PicoConstants.OCTO_SCOPE;
                obj.DriverData.firstRange = range10mV;
                obj.DriverData.lastRange = range50V;
                obj.DriverData.hasHardwareEts = PicoConstants.FALSE;
                obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_256MS;
                obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_20MHZ;
                obj.DriverData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_80MSPS;
                obj.DriverData.isFlexResDevice = PicoConstants.FALSE;
                obj.DriverData.hasIntelligentProbeInterface = PicoConstants.FALSE;
                
            case obj.DriverData.variants.MODEL_PS4225A

                obj.DriverData.channelCount = PicoConstants.DUAL_SCOPE;
                obj.DriverData.firstRange = range50mV;
                obj.DriverData.lastRange = range200V;
                obj.DriverData.hasHardwareEts = PicoConstants.FALSE;
                obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_250MS;
                obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_20MHZ;
                obj.DriverData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_400MSPS;
                obj.DriverData.isFlexResDevice = PicoConstants.FALSE;
                obj.DriverData.hasIntelligentProbeInterface = PicoConstants.TRUE;
            
            case obj.DriverData.variants.MODEL_PS4425A

                obj.DriverData.channelCount = PicoConstants.QUAD_SCOPE;
                obj.DriverData.firstRange = range50mV;
                obj.DriverData.lastRange = range200V;
                obj.DriverData.hasHardwareEts = PicoConstants.FALSE;
                obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_250MS;
                obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_20MHZ;
                obj.DriverData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_400MSPS;
                obj.DriverData.isFlexResDevice = PicoConstants.FALSE;
                obj.DriverData.hasIntelligentProbeInterface = PicoConstants.TRUE;
                
            case obj.DriverData.variants.MODEL_PS4224A

                obj.DriverData.channelCount = PicoConstants.DUAL_SCOPE;
                obj.DriverData.firstRange = range10mV;
                obj.DriverData.lastRange = range50V;
                obj.DriverData.hasHardwareEts = PicoConstants.FALSE;
                obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_256MS;
                obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_20MHZ;
                obj.DriverData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_80MSPS;
                obj.DriverData.isFlexResDevice = PicoConstants.FALSE;
                obj.DriverData.hasIntelligentProbeInterface = PicoConstants.FALSE;
            
            case obj.DriverData.variants.MODEL_PS4424A

                obj.DriverData.channelCount = PicoConstants.QUAD_SCOPE;
                obj.DriverData.firstRange = range10mV;
                obj.DriverData.lastRange = range50V;
                obj.DriverData.hasHardwareEts = PicoConstants.FALSE;
                obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_256MS;
                obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_20MHZ;
                obj.DriverData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_80MSPS;
                obj.DriverData.isFlexResDevice = PicoConstants.FALSE;
                obj.DriverData.hasIntelligentProbeInterface = PicoConstants.FALSE;
                
            case obj.DriverData.variants.MODEL_PS4824A

                obj.DriverData.channelCount = PicoConstants.OCTO_SCOPE;
                obj.DriverData.firstRange = range10mV;
                obj.DriverData.lastRange = range50V;
                obj.DriverData.hasHardwareEts = PicoConstants.FALSE;
                obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_256MS;
                obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_20MHZ;
                obj.DriverData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_80MSPS;
                obj.DriverData.isFlexResDevice = PicoConstants.FALSE;
                obj.DriverData.hasIntelligentProbeInterface = PicoConstants.FALSE;
                
            case obj.DriverData.variants.MODEL_PS4823

                obj.DriverData.channelCount = PicoConstants.OCTO_SCOPE;
                obj.DriverData.firstRange = range10mV;
                obj.DriverData.lastRange = range50V;
                obj.DriverData.hasHardwareEts = PicoConstants.FALSE;
                obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_256MS;
                obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_20MHZ;
                obj.DriverData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_80MSPS;
                obj.DriverData.isFlexResDevice = PicoConstants.FALSE;
                obj.DriverData.hasIntelligentProbeInterface = PicoConstants.FALSE;
                
            otherwise

                obj.DriverData.channelCount = 0;
                obj.DriverData.firstRange = range10mV;
                obj.DriverData.lastRange = range50V;
                obj.DriverData.hasHardwareEts = PicoConstants.FALSE;
                obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_ZERO;
                obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_ZERO;
                obj.DriverData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_ZERO;
                obj.DriverData.isFlexResDevice = PicoConstants.FALSE;
                obj.DriverData.hasIntelligentProbeInterface = PicoConstants.FALSE;

                disconnect(obj);
                error('Picotech:PS4000AInstrumentDriver:UnitNotSupported', ...
                    'Connect: This device is not supported by the Instrument Driver.');

        end
        
        
        if (obj.DriverData.hasIntelligentProbeInterface == PicoConstants.TRUE)
            
            fprintf('Initializing probe interface...\n');
            status = calllib('ps4000aWrap', 'setProbeInteractionCallback', obj.DriverData.unitHandle);
            
            if (status == PicoStatus.PICO_OK)
            
                % Need to wait for probe interaction to detect all connected
                % probes
                % TO DO - check how long it takes to initialise
                pause(2.0);
                fprintf('Probe interface initialization complete.\n');
           
            else
                
               error('Picotech:PS4000AInstrumentDriver:Connect', ...
                ['setProbeInteractionCallback has returned status code ', num2str(status), ...
                ' (0x' dec2hex(status), '). Please refer to PicoStatus.m for further information.' ]); 
                
            end
            
        end
        
        % Confirm the device resolution if it has flexible resolution
        if (obj.DriverData.isFlexResDevice == PicoConstants.TRUE)
            
            pResolution = libpointer('enPS4000ADeviceResolution', obj.DriverData.enums.enPS4000ADeviceResolution.PS4000A_DR_12BIT);
                      
            status = calllib('ps4000a', 'ps4000aGetDeviceResolution', ...
                obj.DriverData.unitHandle, pResolution);
            
            if (status == PicoStatus.PICO_OK)
                
                resolutionEnumValue = pResolution.Value;
                
                switch (resolutionEnumValue)
                    
                    case 'PS4000A_DR_12BIT'
                        
                        obj.DriverData.resolution = 12;
                        
                    case 'PS4000A_DR_14BIT'
                        
                        obj.DriverData.resolution = 14;
                        
                    otherwise
                        
                       warning('PS4000AIDConnect:ps4000aGetDeviceResolution', ['ps4000aGetDeviceResolution '...
                           'returned status code %d.'], status.getResolution);
                        
                end
                
            end
            
        else
            
            obj.DriverData.resolution = 12;
            
        end
        
        % Find Arbitrary Waveform values - if Arbitrary Waveform Generator
        % is present, use default values.

        minArbWaveformValue = 0;
        maxArbWaveformValue = 0;
        minAWGBufferSize = 0;
        obj.DriverData.awgBufferSize = PicoConstants.AWG_BUFFER_ZERO;

        [status, minArbWaveformValue, maxArbWaveformValue, minAWGBufferSize, ...
            obj.DriverData.awgBufferSize] = ...
            calllib('ps4000a', 'ps4000aSigGenArbitraryMinMaxValues', ...
            obj.DriverData.unitHandle, minArbWaveformValue, ...
            maxArbWaveformValue, minAWGBufferSize, obj.DriverData.awgBufferSize);

        if (status == PicoStatus.PICO_OK)

            obj.DriverData.sigGenType = PicoConstants.SIG_GEN_AWG;
            obj.DriverData.dacFrequency = PicoConstants.AWG_DAC_FREQUENCY_80MHZ;

        else

            obj.DriverData.sigGenType = PicoConstants.SIG_GEN_NONE;
            obj.DriverData.dacFrequency = PicoConstants.AWG_DAC_FREQUENCY_ZERO;

        end
        
        % Set the max. ADC value
    
        maxValue = 0;

        [maxValueStatus, obj.DriverData.maxADCValue]  = calllib('ps4000a', ...
            'ps4000aMaximumValue', obj.DriverData.unitHandle, maxValue);

        clear maxValue;
        clear maxValueStatus;

        % Set the min. ADC value 

        minValue = 0;

        [minValueStatus, obj.DriverData.minADCValue]  = calllib('ps4000a', ...
            'ps4000aMinimumValue', obj.DriverData.unitHandle, minValue);

        clear minValue;
        clear minValueStatus;
        
        obj.DriverData.autoTriggerMs = 0;
        obj.DriverData.delay = 0;
        
        % Set the default number of pre-trigger and post-trigger samples
        obj.DriverData.numPreTriggerSamples = 0;

        obj.DriverData.numPostTriggerSamples = 1000000;

        totalSamples = obj.DriverData.numPreTriggerSamples + obj.DriverData.numPostTriggerSamples;

        % Set the timebase - 1us sampling interval (1MS/s) 
        obj.DriverData.timebase = 79;

        obj.DriverData.streamingInterval = 1e-6; % 1us -&gt; 1MS/s
        obj.DriverData.autoStop = PicoConstants.TRUE;
        
        obj.DriverData.streamingInterval = 1e-6; % 1us -&gt; 1MS/s
        obj.DriverData.autoStop = PicoConstants.TRUE;

        if (obj.DriverData.sigGenType == PicoConstants.SIG_GEN_FUNCT_GEN || ...
            obj.DriverData.sigGenType == PicoConstants.SIG_GEN_AWG)
       
            obj.DriverData.startFrequency = 1000;
            obj.DriverData.stopFrequency = 1000;

            obj.DriverData.offsetVoltage = 0;
            obj.DriverData.peakToPeakVoltage = 2000;
       
        end
        
        % Set device parameters
        invoke(obj, 'resetDevice');
        
        % Display unit information to user if not using TMTool
        fprintf('\n');
        fprintf('Connected to PicoScope 4000 Series (A API) device:-\n\n');
        fprintf('      Instrument Model: %s\n', get(obj, 'InstrumentModel'));
        fprintf('   Batch/Serial Number: %s\n', unitSerial);
        fprintf('       Analog Channels: %d\n', get(obj, 'channelCount'));
            
        % Bandwidth information
        bandwidthHz = obj.DriverData.bandwidth;
        
        if(bandwidthHz &gt; 0 &amp;&amp; bandwidthHz &lt; 1e9)
            
           fprintf('             Bandwidth: %d MHz\n', (bandwidthHz/1e6));
           
        elseif(bandwith_hz &gt;= 1e9)
            
           fprintf('             Bandwidth: %d GHz\n', (bandwidthHz/1e9));
           
        else
            
            % Do nothing
            
        end
        
        fprintf('         Buffer memory: %d MS\n', get(obj, 'bufferMemory')/pow2(20));
        
        % Sampling rate information
        maxSamplingRate = obj.DriverData.maxSamplingRate;
        
        if (maxSamplingRate &gt; 0 &amp;&amp; maxSamplingRate &lt; 1e9)
            
            fprintf(' Maximum sampling rate: %d MS/s\n', maxSamplingRate/1e6);
            
        elseif (maxSamplingRate &gt;= 1e9)
           
            fprintf(' Maximum sampling rate: %d GS/s\n', maxSamplingRate/1e9);
            
        else
            
            % Do nothing
            
        end
        
        clear bandwidthHZ;
        clear maxSamplingRate;

        % Output the signal generator type
        sigGenType = 'None';
    
        switch (obj.DriverData.sigGenType)

            case PicoConstants.SIG_GEN_FUNCT_GEN

                sigGenType = 'Function Generator';

            case PicoConstants.SIG_GEN_AWG

                sigGenType = 'Arbitrary Waveform Generator';

            otherwise

                % Already set to none

        end
    
        fprintf(' Signal Generator Type: %s\n', sigGenType);

        fprintf('\n');

    elseif (connectStatus.openUnit == PicoStatus.PICO_NOT_FOUND)

        error('No unit found, please check connections.');

    else

        error('Status code: %d\n', connectStatus.openUnit);

    end</Code>
   </ConnectInitCode>
   <CleanupCode>
      <Type>MCode</Type>
      <Code>function cleanup(obj)
% This function is called before the object is disconnected.
% OBJ is the device object.
% End of function definition - DO NOT EDIT

    if (isfield(obj.DriverData,'unitHandle'))

        unitHandle = obj.DriverData.unitHandle;
    
        if (isempty(unitHandle)) 
            % If no unithandle, return without doing anything
            return;
        end

        if (~libisloaded('ps4000a') &amp;&amp; ~libisloaded('ps4000aWrap'))

            % If the drivers are no longer loaded, return without doing
            % anything
            return;

        end

        % Disconnect Code:

        disconnectStatus = calllib('ps4000a', 'ps4000aCloseUnit', unitHandle);

        if (disconnectStatus == PicoStatus.PICO_OK)

            fprintf(['Connection to PicoScope %s with serial number %s ' ...
                'closed successfully.\n'], obj.InstrumentModel, obj.DriverData.unitSerial);

        elseif (disconnectStatus == PicoStatus.PICO_INVALID_HANDLE)
            
            % No device with the handle, so should be disconnected.
            return;
            
        else
            
            if (isfield(obj.DriverData, 'unitSerial'))

                error('Disconnect:ConnectionNotClosed',['Connection to PicoScope %s with serial number %s ' ...
                    'not closed. Status code %d\n'], ...
                    obj.InstrumentModel, obj.DriverData.unitSerial, disconnectStatus);
                
            end

        end

        % Only unload libraries if there are no more connected
        % oscilloscopes
        
        % Find the first handle number for the platform
        firstHandle = 0;
        
        if (ispc())
            
            firstHandle = 16384; % Windows PC
            
        else 
           
            firstHandle = 1; % Mac OS X and Linux
            
        end
        
        % Test the connection to a range of handle values up to a maximum
        lastHandle = firstHandle + obj.DriverData.constants.PS4000A_MAX_UNITS - 1;
        
        % Create an array to store status values for ping tests.
        % On Windows PCs, the first handle is 16384 so this will need to be
        % accounted for.
        if (ispc())
            
            pingStatus = zeros(lastHandle, 1);
            
        else
            
            pingStatus = zeros(obj.DriverData.constants.PS4000A_MAX_UNITS, 1);
            
        end
        
        % Test the handle value ranges
        for h = firstHandle:lastHandle

            pingStatus(h, 1) = calllib('ps4000a', 'ps4000aPingUnit', h);
            
        end
        
        if (ispc())
                
            % Need to resize arrray as first handle is not 0
            pingStatus(1:firstHandle - 1) = [];
                
        end
        
        if (any(pingStatus == PicoStatus.PICO_OK))
         
          % Device still connected
          disp('Other PicoScope 4000 Series devices using the ps4000a shared library are still connected - libraries will not be unloaded.');
          
        else

            unloadlibrary('ps4000aWrap');
            unloadlibrary('ps4000a');
            
            if (~libisloaded('ps4000a') &amp;&amp; ~libisloaded('ps4000aWrap'))

                disp('Libraries unloaded successfully.');

            else

                error('Libraries not unloaded.');

            end

        end
        
    else
        
        warning('Disconnect:NoDevicesFound', 'Disconnect: No devices found.');
        
    end
        
    </Code>
   </CleanupCode>
   <GroupInfo>
      <Group>
         <Name>parent</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="parent1" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>bandwidth</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
    
    propertyValue = obj.DriverData.bandwidth;
    </GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>bandwidth represents the maximum bandwidth (3dB cut-off point) of the oscilloscope in Hertz.</Description>
            </Property>
            <Property>
               <Name>bufferMemory</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.bufferMemory;
</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>268435456</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>Defines the size of the memory buffer on the device (in samples).</Description>
            </Property>
            <Property>
               <Name>channelCount</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.channelCount;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="8.0" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>The number of analog input channels on the device.</Description>
            </Property>
            <Property>
               <Name>channelSettings</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.channelSettings;
    </GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Object</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue/>
               <ReadOnly>always</ReadOnly>
               <Description>A matrix containing the channel settings for analog channels.

This will consist of a channelCount x 4 matrix.

The row number will correspond to the channel:

1 - Channel A
2 - Channel B
3 - Channel C
4 - Channel D
5 - Channel E
6 - Channel F
7 - Channel G
8 - Channel H

Each row will contain the following elements corresponding to:

enabled - set to 0 (off) or 1 (on).
dc - set DC/AC coupling. 
range - an enumeration representing the voltage range.
analogueOffset - the offset on the channel.

</Description>
            </Property>
            <Property>
               <Name>displayOutput</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.displayOutput;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.DriverData.displayOutput = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>1</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Enumeration value to select whether to display output from function calls in the MATLAB Command Window.

Set to 1 to display output, 0 to hide output.

Note: Output will still be sent to the Command Window when calling the icdevice, connect and disconnect functions. Warning and error messages will still continue to be displayed from function calls.
</Description>
            </Property>
            <Property>
               <Name>firstRange</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.firstRange;
    </GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                     <Value>2.0</Value>
                     <Value>3.0</Value>
                     <Value>4.0</Value>
                     <Value>5.0</Value>
                     <Value>6.0</Value>
                     <Value>7.0</Value>
                     <Value>8.0</Value>
                     <Value>9.0</Value>
                     <Value>10.0</Value>
                     <Value>11.0</Value>
                     <Value>12.0</Value>
                     <Value>13.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>2</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>Enumeration corresponding to the lowest voltage range supported by the device.</Description>
            </Property>
            <Property>
               <Name>hasHardwareEts</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
  
    propertyValue = obj.DriverData.hasHardwareEts;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0.0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>Indicates if the device has hardware-based Equivalent Time Sampling.</Description>
            </Property>
            <Property>
               <Name>hasIntelligentProbeInterface</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
    
    propertyValue = obj.DriverData.hasIntelligentProbeInterface;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Specifies whether the PicoScope model has an intelligent probe interface for use with PicoConnect (TM) probes.</Description>
            </Property>
            <Property>
               <Name>isFlexResDevice</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.isFlexResDevice;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Indicates if the device is a FlexRes® oscilloscope.</Description>
            </Property>
            <Property>
               <Name>lastRange</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
    
    propertyValue = obj.DriverData.lastRange;
    </GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                     <Value>2.0</Value>
                     <Value>3.0</Value>
                     <Value>4.0</Value>
                     <Value>5.0</Value>
                     <Value>6.0</Value>
                     <Value>7.0</Value>
                     <Value>8.0</Value>
                     <Value>9.0</Value>
                     <Value>10.0</Value>
                     <Value>11.0</Value>
                     <Value>12.0</Value>
                     <Value>13.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>10</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>Enumeration corresponding to highest voltage range supported by device.</Description>
            </Property>
            <Property>
               <Name>maxADCValue</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
    
    propertyValue = obj.DriverData.maxADCValue;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="32767.0" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>32767</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>The maximum ADC count value for the device.</Description>
            </Property>
            <Property>
               <Name>maxSamplingRate</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.maxSamplingRate;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="400.0" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>The maximum single shot sampling rate for the device (samples per second).</Description>
            </Property>
            <Property>
               <Name>minADCValue</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
    
    propertyValue = obj.DriverData.minADCValue;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>-32767</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>The minimum ADC count value for the device.</Description>
            </Property>
            <Property>
               <Name>numPostTriggerSamples</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
    
    propertyValue = obj.DriverData.numPostTriggerSamples;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.DriverData.numPostTriggerSamples = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="4.294967295E9" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>1000000</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The number of samples to be taken after a trigger event.

If no trigger event has been set then this specifies the maximum number of samples to be taken. If a trigger
condition has been set, this specifies the number of samples to be taken after a trigger has fired, and the number of samples to be collected is then: -

noOfPreTriggerSamples + noOfPostTriggerSamples

When used in Streaming mode, this is the maximum number of raw samples after a trigger event for each enabled channel.</Description>
            </Property>
            <Property>
               <Name>numPreTriggerSamples</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
    
    propertyValue = obj.DriverData.numPreTriggerSamples;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.DriverData.numPreTriggerSamples = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="4.294967295E9" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The number of samples to return before the trigger event.

If no trigger has been set then this argument is ignored and noOfPostTriggerSamples specifies the maximum number of samples to collect.

When used in Streaming mode, this is the maximum number of raw samples before the trigger event for each enabled channel.
</Description>
            </Property>
            <Property>
               <Name>resolution</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    % Find the device resolution if it has Flexible resolution.
    % If it does not, the default resolution of 12 bits should be returned.
    if (obj.DriverData.isFlexResDevice == PicoConstants.TRUE)
    
        pResolution = libpointer('enPS4000ADeviceResolution', obj.DriverData.enums.enPS4000ADeviceResolution.PS4000A_DR_12BIT);
                      
        status = calllib('ps4000a', 'ps4000aGetDeviceResolution', obj.DriverData.unitHandle, pResolution);

        if (status == PicoStatus.PICO_OK)

            resolutionEnumValue = pResolution.Value;

            switch (resolutionEnumValue)

                case 'PS4000A_DR_12BIT'

                    obj.DriverData.resolution = 12;

                case 'PS4000A_DR_14BIT'

                    obj.DriverData.resolution = 14;

                otherwise

                   error('Picotech:PS4000AInstrumentDriver:GetResolution', ['ps4000aGetDeviceResolution has returned ' ...
                       num2str(status), ' (0x' dec2hex(status), '). Please refer to PicoStatus.m for further information.' ]);

            end

        end
        
    end
       
    propertyValue = obj.DriverData.resolution;
        
</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>12.0</Value>
                     <Value>14.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>12.0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The resolution of the device, in bits.</Description>
            </Property>
            <Property>
               <Name>timebase</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.timebase;
</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.DriverData.timebase = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="4.294967295E9" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>79</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The timebase used for the scope when capturing data in Block and Rapid Block mode - please refer to the Programmer's Guide for the formulae to calculate the timebase index based on the interval.</Description>
            </Property>
            <Property>
               <Name>unitHandle</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.unitHandle;
</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="32767.0" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>The handle assigned by the underlying driver for the device.</Description>
            </Property>
            <Property>
               <Name>unitSerial</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.unitSerial;
</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue/>
               <ReadOnly>always</ReadOnly>
               <Description>The device batch/serial number.</Description>
            </Property>
         </PropertyInfo>
         <MethodInfo>
            <Method>
               <Name>deviceReset</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function deviceReset(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Show warning message
    warning('PS4000AInstrumentDriver:DeviceResetNotSupported', ...
        'devicereset is not supported by this Instrument Driver - please use the resetDevice function instead.');</MCode>
               </Code>
               <Description>The devicereset function is not supported by this Instrument Driver. Please use the resetDevice function instead.</Description>
            </Method>
            <Method>
               <Name>getChannelInputRangeAndUnits</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [range, units] = getChannelInputRangeAndUnits(obj, channel)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    if (channel &gt;= obj.DriverData.enums.enPS4000AChannel.PS4000A_CHANNEL_A &amp;&amp; ...
        channel &lt; obj.DriverData.channelCount)
        
        % Obtain range from channel settings

        chSettingsIndex = channel + 1;
        channelRange = obj.DriverData.channelSettings(chSettingsIndex, 3);

        % Determine the probe type based on the range
        
        if (channelRange &gt;= obj.DriverData.enums.enPicoConnectProbeRange.PICO_CURRENT_CLAMP_200A_2kA_1A &amp;&amp; ...
            channelRange &lt;= obj.DriverData.enums.enPicoConnectProbeRange.PICO_CURRENT_CLAMP_200A_2kA_2000A)
        
            % Find the index to use to obtain the correct range from the
            % array of possible ranges for the probe.
            rangeIndex = channelRange - obj.DriverData.enums.enPicoConnectProbeRange.PICO_CURRENT_CLAMP_200A_2kA_1A + 1;
            
            range = obj.DriverData.constants.PICO_CONNECT_PROBE_CURRENT_CLAMP_200_2KA_RANGES(rangeIndex);
            units = 'A';
        
        elseif (channelRange &gt;= obj.DriverData.enums.enPicoConnectProbeRange.PICO_CURRENT_CLAMP_40A_100mA &amp;&amp; ...
                    channelRange &lt;= obj.DriverData.enums.enPicoConnectProbeRange.PICO_CURRENT_CLAMP_40A_40A)
                
            % Find the index to use to obtain the correct range from the
            % array of possible ranges for the probe.
            rangeIndex = channelRange - obj.DriverData.enums.enPicoConnectProbeRange.PICO_CURRENT_CLAMP_40A_100mA + 1;
            
            range = obj.DriverData.constants.PICO_CONNECT_PROBE_CURRENT_CLAMP_40A_RANGES(rangeIndex);
            units = 'A';
        
        elseif (channelRange &gt;= obj.DriverData.enums.enPicoConnectProbeRange.PICO_1KV_2_5V &amp;&amp; ...
                    channelRange &lt;= obj.DriverData.enums.enPicoConnectProbeRange.PICO_1KV_1000V)

            % Find the index to use to obtain the correct range from the
            % array of possible ranges for the probe.
            rangeIndex = channelRange - obj.DriverData.enums.enPicoConnectProbeRange.PICO_1KV_2_5V + 1;
            
            range = obj.DriverData.constants.PICO_CONNECT_PROBE_CAT3_HV_1KV_RANGES(rangeIndex);
            units = 'V';
           
        elseif (channelRange &gt;= obj.DriverData.enums.enPicoConnectProbeRange.PICO_CURRENT_CLAMP_2000ARMS_10A &amp;&amp; ...
                    channelRange &lt;= obj.DriverData.enums.enPicoConnectProbeRange.PICO_CURRENT_CLAMP_2000ARMS_5000A)
                
            % Find the index to use to obtain the correct range from the
            % array of possible ranges for the probe.
            rangeIndex = channelRange - obj.DriverData.enums.enPicoConnectProbeRange.PICO_CURRENT_CLAMP_2000ARMS_10A + 1;
            
            range = obj.DriverData.constants.obj.DriverData.constants.PICO_CONNECT_PROBE_CURRENT_CLAMP_2000ARMS_RANGES(rangeIndex);
            units = 'A';
 
        else
        
            % Standard scope input ranges
            range = PicoConstants.SCOPE_INPUT_RANGES(channelRange + 1);
            units = 'mV';
                
        end
        
    else
       
        error('Picotech:PS4000AInstrumentDriver:getChannelInputRangeAndUnitsInvalidChannel', ...
                'getChannelInputRangeAndUnits: Invalid channel argument.');
        
    end</MCode>
               </Code>
               <Description>getChannelInputRangeAndUnits(obj, channel)  returns the range set for a channel and corresponding units 

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
channel - the channel to be configured (an enumeration from the enPS4000AChannel range)

Output parameters:

range - the input range set for the channel. This will be returned as the positive maximum value for the input range set e.g. 5000 for a +/- 5 V range for a standard probe, or 2 for a +/- 2 A range for a current probe.
units - the corresponding units for the range e.g. mV, V or A depending on the probe connected.</Description>
            </Method>
            <Method>
               <Name>getUnitInfo</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, unitInfoValues] = getUnitInfo(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    unitHandle = obj.DriverData.unitHandle;
    
    unitInfoDesc = {'Driver version: '; 'USB version: '; 'Hardware version: '; 'Variant: '; ...
        'Batch &amp; Serial: '; 'Cal. Date: '; 'Kernel version: '; 'Digital HW version: '; ...
        'Analogue HW version: '; 'Firmware 1: '; 'Firmware 2: '};

    infoLine = blanks(40);

    unitInfoValues = cell(11,1);

    reqSize = 40;

    status = zeros(11,1,'uint32');

    % Loop through and put together information
    for n = 1:11

        [status(n,1), infoLine1, reqSize]  = calllib('ps4000a', ...
            'ps4000aGetUnitInfo', unitHandle, infoLine, ... 
            length(infoLine), reqSize,(n-1));
        
        if(status(n,1) ~= PicoStatus.PICO_OK)
           
            error('getUnitInfo: Status code:- %d Status code: %d. Please refer to the PicoStatus.m file.', status(n,1)); 
        
        end

        unitInfoLine = strcat(unitInfoDesc(n), infoLine1);
        unitInfoValues(n) = cellstr(unitInfoLine);
        
    end</MCode>
               </Code>
               <Description>GetUnitInfo(obj) retrieves information about the specified oscilloscope for the following types of information:

1.   Driver version
2.   USB version
3.   Hardware version
4.   Variant number
5.   Batch &amp; Serial number
6.   Calibration date
7.   Kernel Version
8.   Digital Hardware version
9.   Analog Hardware version
10. Firmware 1
11. Firmware 2

Input parameters:

obj - the object representing the device.

Output parameters:

status - an array containing the status codes returned by the driver on each call to the underlying ps4000aGetUnitInfo function.
unitInfoValues - a set of text providing information on the device connected to.

For further information on the underlying ps4000aGetUnitInfo function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps4000aChangePowerSource</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps4000aChangePowerSource(obj, powerstate)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    status = calllib('ps4000a', 'ps4000aChangePowerSource', ...
        obj.DriverData.unitHandle, powerstate);
                
    if(status ~= PicoStatus.PICO_OK)
        
        error('ps4000aChangePowerSource:- Status code: %d. Please refer to the PicoStatus.m file.', status);
        
    end</MCode>
               </Code>
               <Description>ps4000aChangePowerSource(obj, powerstate) controls the two-stage power-up sequence when the device is plugged
into a non-USB 3.0 port.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
powerstate - the required state of the unit - PicoStatus.PICO_USB3_0_DEVICE_NON_USB3_0_PORT.

Output parameters:

status - the status code returned by the driver.

For further information on the ps4000aChangePowerSource function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps4000aCurrentPowerSource</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps4000aCurrentPowerSource(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    status = calllib('ps4000a', 'ps4000aCurrentPowerSource', ...
        obj.DriverData.unitHandle);
    
    if(status ~= PicoStatus.PICO_OK)
        
        error('ps4000aChangePowerSource:- Status code: %d. Please refer to the PicoStatus.m file.', status);
        
    end</MCode>
               </Code>
               <Description>ps4000aCurrentPowerSource(obj) returns the current power state of the device.

There is no need to call this function with the PicoScope 4824.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.

Output parameters:

status - the current power state of the device or the status code for an invalid handle.

For further information on the ps4000aCurrentPowerSource function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps4000aFlashLed</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps4000aFlashLed(obj, start)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    status = calllib('ps4000a', 'ps4000aFlashLed', ...
        obj.DriverData.unitHandle, start);
            
	if(status ~= PicoStatus.PICO_OK)
           
        error('ps4000aFlashLed:- Status code: %d. Please refer to the PicoStatus.m file.', status);
        
    end</MCode>
               </Code>
               <Description>ps4000aFlashLed(obj, start) flashes the LED on the front of the scope without blocking the calling thread.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
start - the action required:

	&lt; 0 : flash the LED indefinitely.
	0 : stop the LED flashing.
	&gt; 0 : flash the LED start times.

Output parameters:

status - the status code returned by the device.

For further information on the ps4000aFlashLed function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps4000aGetAnalogueOffset</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, maximumVoltage, minimumVoltage] = ps4000aGetAnalogueOffset(obj, range, coupling)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Values to be used for pointers
    maxVoltage = 0.0;    
    minVoltage = 0.0;

    [status, maximumVoltage, minimumVoltage] = calllib('ps4000a', ...
        'ps4000aGetAnalogueOffset', obj.DriverData.unitHandle, ...
        range, coupling, maxVoltage, minVoltage);
    
    clear maxVoltage;
    clear minVoltage;
    
    if(status ~= PicoStatus.PICO_OK)
       
        error('ps4000aGetAnalogueOffset:- Status code: %d. Please refer to the PicoStatus.m file.', status);
    
    end</MCode>
               </Code>
               <Description>ps4000aGetAnalogueOffset(obj, range, coupling) is used to get the maximum and minimum allowable analogue offset for a specific voltage range.

This function may be used with the Test and Measurement Tool.

Input parameters: 

obj - the object representing the device.
range - an enumeration representing the voltage range to be used.
coupling - an enumeration representing the the type of AC/DC coupling used.

Output parameters:

status - the status code returned by the driver.
maximumVoltage - the maximum voltage allowed for the range.
minimumVoltage - the minimum voltage allowed for the range.

For further information on the ps4000aGetAnalogueOffset function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.


</Description>
            </Method>
            <Method>
               <Name>ps4000aGetChannelInformation</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, ranges, length] = ps4000aGetChannelInformation(obj, channels)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Current info supported is PS4000A_CI_RANGES
    info = obj.DriverData.enums.enPS4000AChannelInfo.PS4000A_CI_RANGES;
    probe = 0;
    ranges = zeros(10, 1);
    length = 0;

    [status, ranges, length] = calllib('ps4000a', ...
        'ps4000aGetChannelInformation', obj.DriverData.unitHandle, info, ...
        0, ranges, length, channels);
    
    
    clear info;
    clear probe;
    
    if(status ~= PicoStatus.PICO_OK)
           
       error('ps4000aGetChannelInformation:- Status code: %d. Please refer to the PicoStatus.m file.', status);
        
    end   </MCode>
               </Code>
               <Description>ps4000aGetChannelInformation(obj, channels) queries which extra voltage ranges are available on a scope device.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
channels - the channel for which the range information is required.

Output parameters:

status - the status code returned by the driver.
ranges - an array that will be populated with available PS4000A_RANGE enumeration values.
length - the number of elements written to the ranges array.

Note that the enumerations start from 0 and should be offset by +1 to be used with the SCOPE_INPUT_RANGES array in the PicoConstants class.

For further information on the ps4000aGetChannelInformation function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps4000aGetMaxDownSampleRatio</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, maxDownSampleRatio] = ps4000aGetMaxDownSampleRatio(obj, numUnaggregatedSamples, downSampleRatioMode, segmentIndex)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Value to which the max downsample ration is assigned
    maxDownSampleRatio = 0;        

    [status, maxDownSampleRatio] = calllib('ps4000a', ...
        'ps4000aGetMaxDownSampleRatio', get(obj, 'unitHandle'), numUnaggregatedSamples, ...
            maxDownSampleRatio, downSampleRatioMode, segmentIndex);
        
    if(status ~= PicoStatus.PICO_OK)
           
       error('ps4000aGetMaxDownSampleRatio:- Status code: %d. Please refer to the PicoStatus.m file.', status);
        
    end   </MCode>
               </Code>
               <Description>ps4000aGetMaxDownSampleRatio(obj, numUnaggregatedSamples, downSampleRatioMode, segmentIndex) returns the maximum downsampling ratio that can be used for a given number of samples in a given downsampling mode.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
numUnaggregatedSamples - the number of unprocessed samples to be downsampled.
downSampleRatioMode - the downsampling mode.
segmentIndex - the memory segment where the data is stored.

Output parameters:

status - the status code returned by the driver.
maxDownSampleRatio - the maximum possible downsampling ratio.

For further information on the ps4000aGetMaxDownSampleRatio function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps4000aGetMaxSegments</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, maxSegments] = ps4000aGetMaxSegments(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Passing pointer to function
    maxSegments = 0; 

    [status, maxSegments] = calllib('ps4000a', 'ps4000aGetMaxSegments', ...
                                onk.DriverData.unitHandle, maxSegments);
                            
	if(status ~= PicoStatus.PICO_OK)
           
		error('ps4000aGetMaxSegments:- Status code: %d. Please refer to the PicoStatus.m file.', status);
        
    end</MCode>
               </Code>
               <Description>ps4000aGetMaxSegments(obj) returns the maximum number of segments allowed for the opened device.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.

Output parameters:

status - the status code returned by the driver.
maxSegments - the maximum number of segments allowed.

For further information on the ps4000aGetMaxSegments function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.
</Description>
            </Method>
            <Method>
               <Name>ps4000aGetTimebase2</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, timeIntervalNanoSeconds, maxSamples] = ps4000aGetTimebase2(obj, timebase, segmentIndex)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    timeIntervalNanoSeconds = 0;
    
    numSamples = obj.DriverData.numPreTriggerSamples + ...
        obj.DriverData.numPostTriggerSamples;
    
    maxSamples = 0; % Pass data to return the max samples from the driver
    
    [status, timeIntervalNanoSeconds, maxSamples] = calllib('ps4000a', ...
        'ps4000aGetTimebase2', obj.DriverData.unitHandle, timebase, numSamples, ...
        timeIntervalNanoSeconds, maxSamples, segmentIndex);
    
    if (status ~= PicoStatus.PICO_OK)
        
        % Inform the User that an invalid timebase index has been selected
        if (status == PicoStatus.PICO_INVALID_TIMEBASE)
           
            warning('PS4000AInstrumentDriver:InvalidTimebase', ['Invalid timebase ', ...
                'index used in call to ps4000aGetTimebase2().']);
            
        else
            
            error('PS4000AInstrumentDriver:PS4000aGetTimebase2', ['ps4000aGetTimebase2:- Status code: ', ...
                '%d. Please refer to the PicoStatus.m file.'], status);
        
        end
        
    end
    
    clear numSamples;</MCode>
               </Code>
               <Description>ps4000aGetTimebase2(obj, timebase, segmentIndex) discovers which timebases are available on the oscilloscope, returning the time interval as floating point values.

The channels should be setup using the ps4000aSetChannel function first.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
timebase: a timebase index.
segmentIndex: the index of the memory segment to use.

Output parameters:

status - the status code returned by the driver.
timeIntervalNanoSeconds: the time interval between readings at the selected timebase.
maxSamples: the maximum number of samples available. 

For further information on the ps4000aGetTimebase2 function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps4000aIsLedFlashing</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, ledFlashing] = ps4000aIsLedFlashing(obj)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

    ledFlashing = 0;
    
    [status, ledFlashing] = calllib('ps4000a', 'ps4000aIsLedFlashing', ...
        obj.DriverData.unitHandle, ledFlashing);
            
	if(status ~= PicoStatus.PICO_OK)
           
        error('ps4000aIsLedFlashing:- Status code: %d. Please refer to the PicoStatus.m file.', status); 
        
    end</MCode>
               </Code>
               <Description>ps4000aIsLedFlashing(obj) reports whether or not the LED is flashing.

Input parameters:

obj - the object representing the device.

Output parameters:

status - the status code returned by the driver.
ledFlashing - 0, if not flashing, non-zero if flashing.

For further information on the ps4000aIsLedFlashing function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps4000aMemorySegments</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, nMaxSamples] = ps4000aMemorySegments(obj, nSegments)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

    nMaxSamples = 0; % Initialise value for pointer

    [status, nMaxSamples] = calllib('ps4000a', 'ps4000aMemorySegments', ...
        obj.DriverData.unitHandle, nSegments, nMaxSamples);
    
    if(status ~= PicoStatus.PICO_OK)
           
        error('ps4000aMemorySegments:- Status code: %d. Please refer to the PicoStatus.m file.', status); 
        
    end</MCode>
               </Code>
               <Description>ps4000aMemorySegments(obj, nSegments) sets the number of memory segments that the scope will use.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
nSegments - the number of segments required from 1 to the number of maximum segments returned by ps4000GetMaxSegments:

		PicoScope 4824: 125000 segments

Output parameters:

status - the status code returned by the driver.
nMaxSamples - the number of samples available in each segment.

For further information on the ps4000aMemorySegments function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps4000aSetBandwidthFilter</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps4000aSetBandwidthFilter(obj, channel, bandwidth)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
  
    % Check if channel between 0 (Channel A) and channel count - 1
    if (channel &lt; obj.DriverData.enums.enPS4000AChannel.PS4000A_CHANNEL_A || channel &gt;= obj.DriverData.channelCount)
 
         error('ps4000aSetBandwidthFilter:InvalidChannel', 'Invalid channel number (should be 0 (A) to 3 (D)');    
 
    end
 
    status = calllib('ps4000a', 'ps4000aSetBandwidthFilter', ...
                obj.DriverData.unitHandle, channel, bandwidth);
 
    if (status ~= PicoStatus.PICO_OK)
 
        if (status == PicoStatus.PICO_NOT_USED)
            
            warning('ps4000aSetBandwidthFilter:NotSupportedByDevice', ['Device does not '...
                'have bandwidth limiter. No setting has been applied.']);
            
        elseif (status == PicoStatus.PICO_INVALID_BANDWIDTH)
            
            warning('ps4000aSetBandwidthFilter:InvalidBandwidth', ['Invalid bandwidth selected. ', ...
                'Please check and try again']);
            
        else
            
            error('ps4000aSetBandwidthFilter:OtherError', 'ps4000aSetBandwidthFilter - error code %d\n', status);
            
        end
 
    end



   
        
   </MCode>
               </Code>
               <Description>ps4000aSetBandwidthFilter(obj, channel, bandwidth) specifies the bandwidth limit.

This function is reserved for future use.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
channel - the channel to be configured (an enumeration from the PS4000A_CHANNEL range).
bandwidth - the bandwidth is either 0 (Full Bandwidth) or 1 (20MHz).

Output parameters:

status - the status code returned by the driver.

For further information on the ps4000aSetBandwidthFilter function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps4000aSetChannel</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps4000aSetChannel(obj, channel, enabled, type, range, analogueOffset)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.
    
    status = calllib('ps4000a', 'ps4000aSetChannel', ...
        obj.DriverData.unitHandle, channel, enabled, type, ...
        range, analogueOffset);
    
    % Obtain channel settings information 
    chSettings = obj.DriverData.channelSettings;

	if (status == PicoStatus.PICO_OK)

        chSetIndex = channel + 1;
        
        chSettings(chSetIndex, 1) = enabled;
        chSettings(chSetIndex, 2) = type;
        chSettings(chSetIndex, 3) = range;
        chSettings(chSetIndex, 4) = analogueOffset; 

        obj.DriverData.channelSettings = chSettings;
        
        % Information to be passed to the wrapper library
        enabledChannels = zeros(PicoConstants.OCTO_SCOPE, 1, 'int16');

        switch(obj.DriverData.channelCount)
            
            case PicoConstants.DUAL_SCOPE
           
                % Only channels A and B
                enabledChannels = [chSettings(1,1); ...
                    chSettings(2,1); 0; 0; 0; 0; 0; 0];
            
            case PicoConstants.QUAD_SCOPE
                
                enabledChannels = [chSettings(1,1); ...
                    chSettings(2,1); ...
                    chSettings(3,1); ...
                    chSettings(4,1); ...
                    0; 0; 0; 0];
            
            case PicoConstants.OCTO_SCOPE
                
                enabledChannels = [chSettings(1,1); ...
                    chSettings(2,1); chSettings(3,1); ...
                    chSettings(4,1); chSettings(5,1); ...
                    chSettings(6,1); chSettings(7,1); ...
                    chSettings(8,1)];
            
            otherwise
        
                % Do nothing
            
        end
        
        setEnabledChannelsStatus = calllib('ps4000aWrap', ...
                    'setEnabledChannels', obj.DriverData.unitHandle, ...
                    enabledChannels);
        
    else
        
        switch status
            
            case PicoStatus.PICO_INVALID_CHANNEL
           
                error('Picotech:PS4000AInstrumentDriver:ps4000aSetChannel', 'ps4000aSetChannel: Invalid channel selected.');
                
            case PicoStatus.PICO_WARNING_PROBE_CHANNEL_OUT_OF_SYNC
                disp(['Warning:- ps4000aSetChannel: Probe state change detected on channel ', ...
                    char('A' + channel), '. Please call ps4000aSetChannel with the correct settings.'])
                %warning('Picotech:PS4000AInstrumentDriver:ps4000aSetChannel', ['ps4000aSetChannel: Probe state change detected on channel ', ...
                %    char('A' + channel), '. Please call ps4000aSetChannel with the correct settings.']);
            
            otherwise
            
                error('Picotech:PS4000AInstrumentDriver:ps4000aSetChannel', ...
                ['ps4000aSetChannel has returned status code ', num2str(status), ...
                ' (0x' dec2hex(status), '). Please refer to PicoStatus.m for further information.' ]);
            
        end
        
    end</MCode>
               </Code>
               <Description>ps4000aSetChannel(obj, channel, enabled, type, range, analogueOffset) specifies whether an input channel is to be enabled, its input coupling type, voltage range, analog offset and bandwidth limit.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
channel - the channel to be configured (an enumeration from the PS4000A_CHANNEL range - PS4000A_CHANNEL_A to PS4000A_CHANNEL_H).
enabled - set to TRUE (1) to enable the channel, FALSE (0) otherwise.
type - the impedance and coupling type (an enumeration from the PS4000A_COUPLING range).
range - the input voltage range (an enumeration from the PS4000A_RANGE range).
analogueOffset - a voltage to add to the input channel before digitization.

Output parameters:

status - the status code returned by the driver.

For further information on the ps4000aSetChannel function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps4000aSetDataBuffer</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps4000aSetDataBuffer(obj, channel, pBuffer, bufferLth, segmentIndex, mode)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

    status = calllib('ps4000a', 'ps4000aSetDataBuffer', ...
        obj.DriverData.unitHandle, channel, pBuffer, bufferLth, ...
        segmentIndex, mode);
            
    if(status ~= PicoStatus.PICO_OK)
           
        error('ps4000aSetDataBuffer:- Status code: %d. Please refer to the PicoStatus.m file.', status); 
        
    end</MCode>
               </Code>
               <Description>ps4000aSetDataBuffer(obj, channel, buffer, bufferLth, segmentIndex, mode) tells the driver where to store the data, either unprocessed or downsampled, that will be returned after the next call to one of the GetValues functions.

Input parameters:

obj - the object representing the device.
channel - the channel to which the buffer corresponds (an enumeration from the PS4000A_CHANNEL range).
pBuffer - a libpointer to a 1-D array to receive the data values for the channel.
bufferLth - the length of the buffer array.
segmentIndex - the number of the memory segment to be used.
mode - the downsampling mode (an enumeration from the PS4000A_RATIO_MODE range).

Output parameters:

status - the status code returned by the device.

If capturing data in streaming mode without aggregation, buffer must also be passed as the driverBuffer argument for the setAppAndDriverBuffers function call.

For further information on the ps4000aSetDataBuffer function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.

</Description>
            </Method>
            <Method>
               <Name>ps4000aSetDataBuffers</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps4000aSetDataBuffers(obj, channel, pBufferMax, pBufferMin, bufferLth, segmentIndex, ratioMode)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

    status = calllib('ps4000a', 'ps4000aSetDataBuffers', ...
        obj.DriverData.unitHandle, channel, pBufferMax, pBufferMin, ...
        bufferLth, segmentIndex, ratioMode);
    
    if(status ~= PicoStatus.PICO_OK)
           
        error('ps4000aSetDataBuffers:- Status code: %d. Please refer to the PicoStatus.m file.', status); 
        
    end</MCode>
               </Code>
               <Description>ps4000aSetDataBuffers(obj, channel, pBufferMax, pBufferMin, bufferLth, segmentIndex, ratioMode) tells the driver the location of one or two buffers for receiving data.

If aggregate mode is not being used, then ps4000aSetDataBuffer can optionally be used instead.

Input parameters:

obj - the object representing the device.
channel -  the channel for which to set the buffers (an enumeration from the PS4000A_CHANNEL range).
pBufferMax - a libpointer to a 1-D array to receive the maximum data values in aggregation mode, or the non-aggregated values otherwise.
pBufferMin -  a libpointer to a 1-D array to receive the minimum aggregated data values. Not used in other downsampling modes.
bufferLth - the size of the arrays to which pBufferMax and pBufferMin are pointers.
segmentIndex - the number of the memory segment to be used.
mode - the downsampling mode to use (an enumeration from the PS4000A_RATIO_MODE range).

Output parameters:

status - the status code returned by the device.

If capturing data in streaming mode with aggregation, pBufferMax and pBufferMin must also be passed as the driverMaxBuffer and driverMinBuffer arguments respectively for the setMaxMinAppAndDriverBuffers function call.

For further information on the ps4000aSetDataBuffers function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps4000aSetDeviceResolution</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps4000aSetDeviceResolution(obj, resolution)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    validateattributes(resolution, {'numeric'}, {'scalar', 'integer', 'positive'});

    % Initialise a value for the resolution.
    deviceRes = obj.DriverData.enums.enPS4000ADeviceResolution.PS4000A_DR_12BIT;
    
    switch(resolution)
            
        case 12
            
            deviceRes = obj.DriverData.enums.enPS4000ADeviceResolution.PS4000A_DR_12BIT;
            
        case 14
            
            deviceRes = obj.DriverData.enums.enPS4000ADeviceResolution.PS4000A_DR_14BIT;
            
        otherwise
       
            error('Picotech:PS4000AInstrumentDriver:InvalidResolution', ...
                   'ps4000aSetDeviceResolution: Resolution must be 12 or 14 bits for the PicoScope 4444.');
    end
    
    status = calllib('ps4000a', 'ps4000aSetDeviceResolution', obj.DriverData.unitHandle, deviceRes);
    
    if (status == PicoStatus.PICO_OK)
           
        % Set local resolution value
        %obj.DriverData.resolution = resolution;
        
        if (obj.DriverData.displayOutput == PicoConstants.TRUE)
            
            fprintf('ps4000aSetDeviceResolution: Device resolution set to %d bits.\n\n', resolution);
            
        end
        
    else
          
        error('Picotech:PS4000AInstrumentDriver:ps4000aSetDeviceResolution', ...
                   ['ps4000aSetDeviceResolution has returned status code ', ...
                   num2str(status), ' (0x' dec2hex(status), '). Please refer to PicoStatus.m for further information.' ]);
               
    end</MCode>
               </Code>
               <Description>ps4000aSetDeviceResolution(obj, resolution) sets the ADC resolution.

This function only applies to the PicoScope 4444.

Input parameters:

obj -  the object representing the device.
resolution - either 12 or 14.

Output parameters:

status - the status code returned by the device.

For further information on the ps4000aSetDeviceResolution function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps4000aStop</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps4000aStop(obj)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

    status = calllib('ps4000a', 'ps4000aStop', obj.DriverData.unitHandle);
    
    if(status ~= PicoStatus.PICO_OK)
           
        error('ps4000aStop:- Status code: %d. Please refer to the PicoStatus.m file.', status); 
        
    end</MCode>
               </Code>
               <Description>ps4000aStop(obj) stops the scope device from sampling data.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.

Output parameters:

status - the status code returned by the driver.

For further information on the ps4000aStop function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>resetDevice</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function resetDevice(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    fprintf('Setting Device Parameters...\n\n');
    
    range10mV = obj.DriverData.enums.enPicoConnectProbeRange.PICO_X1_PROBE_10MV;
    range20mV = obj.DriverData.enums.enPicoConnectProbeRange.PICO_X1_PROBE_20MV;
    range50mV = obj.DriverData.enums.enPicoConnectProbeRange.PICO_X1_PROBE_50MV;
    range50V  = obj.DriverData.enums.enPicoConnectProbeRange.PICO_X1_PROBE_50V;
    range200V = obj.DriverData.enums.enPicoConnectProbeRange.PICO_X1_PROBE_200V;
    
    % Reset Channels
    [status] = invoke(obj, 'setChannelDefaults');

    % Turn off ETS
    
    % disp('Turning off Equivalent Time Sampling...');
    
    %[etsStatus, stPs] = invoke(obj, 'ps4000aSetEts', 0, 0, 0);

    fprintf('Default Block mode parameters:-\n\n');
    
    % Set the default number of pre-trigger and post-trigger samples
    obj.DriverData.numPreTriggerSamples = 0;
    
    obj.DriverData.numPostTriggerSamples = 1000000;
    
    totalSamples = obj.DriverData.numPreTriggerSamples + obj.DriverData.numPostTriggerSamples;
    
    % Set the timebase - 1us sampling interval (1MS/s) 
    obj.DriverData.timebase = 79;
    
    timeIntervalNs = 0;
    segmentIndex = 0;
    
    % Call get timebase to return interval in ns 
    
    [timebaseStatus, timeIntervalNs, maxBlockSamples] = ...
        invoke(obj, 'ps4000aGetTimebase2', obj.DriverData.timebase, segmentIndex);

    fprintf('               Timebase index : %d\n', obj.DriverData.timebase);
    fprintf('                 Time Interval: %.1f ns\n', timeIntervalNs);
    fprintf(' Number of pre-trigger samples: %d\n', obj.DriverData.numPreTriggerSamples);
    fprintf('Number of post-trigger samples: %d\n', obj.DriverData.numPostTriggerSamples);
    fprintf('       Total number of samples: %d\n', totalSamples);
    
    fprintf('\n');
    
    fprintf('Default Streaming mode parameters:-\n\n');
   
    obj.DriverData.streamingInterval = 1e-6; % 1us -&gt; 1MS/s
    obj.DriverData.autoStop = PicoConstants.TRUE;
    
    fprintf(' Streaming interval: %1.2d s\n', obj.DriverData.streamingInterval);
    fprintf('Streaming auto stop: %d\n', obj.DriverData.autoStop);
    
    fprintf('\n');
    
    if (obj.DriverData.sigGenType == PicoConstants.SIG_GEN_FUNCT_GEN || ...
            obj.DriverData.sigGenType == PicoConstants.SIG_GEN_AWG)
       
        fprintf('Default Signal generator parameters:-\n\n');
        
        obj.DriverData.startFrequency = 1000;
        
        obj.DriverData.stopFrequency = 1000;
        
        obj.DriverData.offsetVoltage = 0;
        obj.DriverData.peakToPeakVoltage = 2000;
        
        fprintf('      Start frequency: %d Hz\n', obj.DriverData.startFrequency);
        fprintf('       Stop frequency: %d Hz\n', obj.DriverData.stopFrequency);
        fprintf('       Offset voltage: %d mV\n', obj.DriverData.offsetVoltage);
        fprintf(' Peak to Peak voltage: %d mV\n', obj.DriverData.peakToPeakVoltage);
        
    end
    
    disp('Initialization complete.');</MCode>
               </Code>
               <Description>resetDevice(obj) sets the default parameters for the device.

This includes the folliowing:

1. Device specific properties.
2. Enabling all available channels to 5V range, DC coupled with 0 analog offset.
3. Turning off the trigger:

	- delay is set to 0
	- auto trigger is set to 0 (indefinite wait when a trigger is set).

4. Block mode parameters:

	Timebase index - 79, corresponding to a sampling interval of:

		- 1540ns for the PicoScope 4225 &amp; 4425.
		- 1us for a PicoScope 4824.

	numPreTriggerSamples - 0
 	numPostTriggerSamples - 1000000

5. Streaming mode parameters:

	streamingInterval - 1e-6 (seconds)
	autoStop - 1
    
6. Signal Generator parameters:
        
	offsetVoltage - 0mV
	peakToPeakVoltage - 2000mV
	startFrequency - 1000 (Hz)
	stopFrequency - 1000 (Hz)

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.

Output parameters:

None


</Description>
            </Method>
            <Method>
               <Name>setChannelDefaults</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status] = setChannelDefaults(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    fprintf('Default Channel Setup:-\n');
    fprintf('-----------------------\n\n');

    chA = 0; obj.DriverData.enums.enPS4000AChannel.PS4000A_CHANNEL_A;
    chB = 1; obj.DriverData.enums.enPS4000AChannel.PS4000A_CHANNEL_B;
    chC = 2; obj.DriverData.enums.enPS4000AChannel.PS4000A_CHANNEL_C;
    chD = 3; obj.DriverData.enums.enPS4000AChannel.PS4000A_CHANNEL_D;
    chE = 4; obj.DriverData.enums.enPS4000AChannel.PS4000A_CHANNEL_E;
    chF = 5; obj.DriverData.enums.enPS4000AChannel.PS4000A_CHANNEL_F;
    chG = 6; obj.DriverData.enums.enPS4000AChannel.PS4000A_CHANNEL_G;
    chH = 7; obj.DriverData.enums.enPS4000AChannel.PS4000A_CHANNEL_H;

    channelCount = obj.DriverData.channelCount;
    
    status = zeros(PicoConstants.OCTO_SCOPE, 1);
    
    % Assign values used repeatedly to local variable

    true = PicoConstants.TRUE;
    range5V = obj.DriverData.enums.enPS4000ARange.PS4000A_5V;
    analogueOffset = 0.0;
    
    % Matrix of values to represent channels (rows) x properties (cols)
    obj.DriverData.channelSettings = zeros(channelCount, 4);
    
    % Create a num channels x fields array
    chSettings = zeros(channelCount, 4);

    % Set Channels A through H (device dependent), updating internal settings
    % Parameters are channel index, enabled, dc coupling, range index and 
    % analogue offset

    % Update internal settings
    
    for ch = 1:channelCount
        
        channelSettings(ch).enabled = true;
        channelSettings(ch).dc = true;
        channelSettings(ch).range = range5V;
        channelSettings(ch).offset = analogueOffset;
        
        % Transpose the resulting array and combine together
        chSettings(ch, :) = cell2mat(struct2cell(channelSettings(ch)))';
        
    end
    
    obj.DriverData.channelSettings = chSettings;
    
    status(1) = invoke(obj, 'ps4000aSetChannel', chA, true, true, range5V, analogueOffset);
    fprintf('Channel A:-\n\tEnabled: True\n\tCoupling: DC\n\tRange: 5V\n\tAnalog Offset: 0.0V\n\n');

    status(2) = invoke(obj, 'ps4000aSetChannel', chB, true, true, range5V, analogueOffset);
    fprintf('Channel B:-\n\tEnabled: True\n\tCoupling: DC\n\tRange: 5V\n\tAnalog Offset: 0.0V\n\n');

    if(obj.DriverData.channelCount == PicoConstants.QUAD_SCOPE || ...
            obj.DriverData.channelCount == PicoConstants.OCTO_SCOPE)
        
        status(3) = invoke(obj, 'ps4000aSetChannel', chC, true, true, range5V, analogueOffset);
        fprintf('Channel C:-\n\tEnabled: True\n\tCoupling: DC\n\tRange: 5V\n\tAnalog Offset: 0.0V\n\n');

        status(4) = invoke(obj, 'ps4000aSetChannel', chD, true, true, range5V, analogueOffset);
        fprintf('Channel D:-\n\tEnabled: True\n\tCoupling: DC\n\tRange: 5V\n\tAnalog Offset: 0.0V\n\n');

    end
    
    if(obj.DriverData.channelCount == PicoConstants.OCTO_SCOPE)
        
        status(5) = invoke(obj, 'ps4000aSetChannel', chE, true, true, range5V, analogueOffset);
        fprintf('Channel E:-\n\tEnabled: True\n\tCoupling: DC\n\tRange: 5V\n\tAnalog Offset: 0.0V\n\n');

        status(6) = invoke(obj, 'ps4000aSetChannel', chF, true, true, range5V, analogueOffset);
        fprintf('Channel F:-\n\tEnabled: True\n\tCoupling: DC\n\tRange: 5V\n\tAnalog Offset: 0.0V\n\n');

        status(7) = invoke(obj, 'ps4000aSetChannel', chG, true, true, range5V, analogueOffset);
        fprintf('Channel G:-\n\tEnabled: True\n\tCoupling: DC\n\tRange: 5V\n\tAnalog Offset: 0.0V\n\n');

        status(8) = invoke(obj, 'ps4000aSetChannel', chH, true, true, range5V, analogueOffset);
        fprintf('Channel H:-\n\tEnabled: True\n\tCoupling: DC\n\tRange: 5V\n\tAnalog Offset: 0.0V\n\n');
       
    end
    
    % Clear local variables
    
    clear chA;
    clear chB;
    clear chC;
    clear chD;
    clear chE;
    clear chF;
    clear chG;
    clear chH;
        
    clear true;
    clear range5V;
        </MCode>
               </Code>
               <Description>setChannelDefaults(obj) sets the following default values for any analog channels found on the device:

Analog Channel:

Enabled       : True
Coupling      : DC
Voltage Range : 5V
Analog Offset : 0.0V


This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.

Output parameters:

status - an array corresponding to the status codes returned for setting each channel.

For further information, please also refer to the ps4000aSetChannel function.</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>block</Name>
         <Description>The Block group contains a set of properties and functions related to the block data capture functionality of the device.</Description>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="block" Index="1"/>
         </Mappings>
         <PropertyInfo/>
         <MethodInfo>
            <Method>
               <Name>getBlockData</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [numSamples, overflow, channelA, channelB, channelC, channelD, channelE, channelF, channelG, channelH] = getBlockData(obj, startIndex, segmentIndex, ratio, ratioMode)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    % Check ratio mode is not aggregated 
    if (ratioMode ~= deviceObj.DriverData.enums.enPS4000ARatioMode.PS4000A_RATIO_MODE_AGGREGATE)
            
        unitHandle = deviceObj.DriverData.unitHandle;
        
        channelCount = deviceObj.DriverData.channelCount;
        
        % Retrieve channel settings - channel x data field matrix
        channelSettings = deviceObj.DriverData.channelSettings; 
        
        % Create empty arrays for channel data.
        channelA = [];
        channelB = [];
        channelC = [];
        channelD = [];
        channelE = [];
        channelF = [];
        channelG = [];
        channelH = [];

        % Overflow indicator
        overflow = 0;

        % Initialise variable for array of libpointers
        pBuffer = libpointer;
        
        % Initialise status
        setBufferStatus = 0;

        % total number of samples to set for data buffers
        totalSamples = deviceObj.DriverData.numPreTriggerSamples + deviceObj.DriverData.numPostTriggerSamples;
        
        if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
        
            fprintf('getBlockData: Setting up data buffers...\n');
            
        end
        
        for ch = 1:channelCount

            % Set Data Buffer if channel is enabled - index 1 indicates if
            % channel is enabled
            if (channelSettings(ch,1) == PicoConstants.TRUE)
                
                % Store array of libpointers
                pBuffer(ch) = libpointer('int16Ptr', zeros(totalSamples, 1, 'int16'));

                setBufferStatus = calllib('ps4000a', 'ps4000aSetDataBuffer', ...
                    unitHandle, (ch - 1), pBuffer(ch), totalSamples, ...
                    segmentIndex, ratioMode);
                
                if (setBufferStatus ~= PicoStatus.PICO_OK)
                    
                    error('getBlockData: Set Data Buffer for Channel %d error code %d. Please refer to the PicoStatus.m file.', ...
                        (ch - 1), setBufferStatus);
                    
                end

            end

        end

        if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
            
            fprintf('getBlockData: Retrieving data...\n');
            
        end
        
        [getValuesStatus, numSamples, overflow] = ...
            calllib('ps4000a', 'ps4000aGetValues', unitHandle, startIndex, ...
                totalSamples, ratio, ratioMode, segmentIndex, overflow);
        
        if (getValuesStatus == PicoStatus.PICO_OK)
            
            if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
                
                fprintf('getBlockData: Converting ADC counts and assigning to channel array.\n');
                
            end
            
            % Obtain max ADC count value
            maxADCValue = double(deviceObj.DriverData.maxADCValue);
            
            % Retrieve data values for enabled channels
            for ch = 1:channelCount

                if (channelSettings(ch, 1) == PicoConstants.TRUE)
                    
                    % Obtain the probe input range for the channel.
                    [channelInputRange, ~] = invoke(deviceObj, 'getChannelInputRangeAndUnits', (ch - 1));
                    
                    bufferValues = adc2mv(pBuffer(ch).Value, channelInputRange, maxADCValue);

                    switch (ch - 1)

                        case deviceObj.DriverData.enums.enPS4000AChannel.PS4000A_CHANNEL_A

                            channelA = bufferValues;

                        case deviceObj.DriverData.enums.enPS4000AChannel.PS4000A_CHANNEL_B

                            channelB = bufferValues;

                        case deviceObj.DriverData.enums.enPS4000AChannel.PS4000A_CHANNEL_C

                            channelC = bufferValues;

                        case deviceObj.DriverData.enums.enPS4000AChannel.PS4000A_CHANNEL_D

                            channelD = bufferValues;
                            
                        case deviceObj.DriverData.enums.enPS4000AChannel.PS4000A_CHANNEL_E

                            channelE = bufferValues;

                        case deviceObj.DriverData.enums.enPS4000AChannel.PS4000A_CHANNEL_F

                            channelF = bufferValues;

                        case deviceObj.DriverData.enums.enPS4000AChannel.PS4000A_CHANNEL_G

                            channelG = bufferValues;

                        case deviceObj.DriverData.enums.enPS4000AChannel.PS4000A_CHANNEL_H

                            channelH = bufferValues;

                        otherwise

                            % Do nothing

                    end
                    
                end
                
            end
            
            if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
                
                fprintf('getBlockData: Data succesfully retrieved.\n');
                
            end
            
        else
            
            error('getBlockData:- Error retrieving data values - code: %d. Please refer to the PicoStatus.m file.', getValuesStatus);
            
        end
        
        
    else
        
        error('getBlockData: Aggregate Mode data collection not supported by this function.');
        
    end
</MCode>
               </Code>
               <Description>getBlockData(obj, startIndex, segmentIndex, ratio, ratioMode) returns block mode data with or without downsampling starting at the specified sample number.

Memory for the data arrays is allocated and the driver is informed where to store the data prior to retrieval. Data collection in Aggregation mode or with more than one downsampling mode is NOT supported by this function.

This function can be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Block group.
startIndex - a zero-based index that indicates the start point for data collection. Use zero to start at the first sample.
segmentIndex - the number of the memory segment to be used/where the data is stored. Use 0 if the memory has not been segmented.
ratio - the downsampling factor that will be applied to the raw data.
ratioMode - which downsampling mode to use (specified by an enumeration from the PS4000A_RATIO_MODE range of enumerations excluding PS4000A_RATIO_MODE_AGGREGATE).

Output parameters:

status - the status code returned by the driver.
numSamples - the number of samples retrieved from the driver.
overflow - a set of flags that indicate whether an overvoltage has occurred on any of the channels.
channelA - an array containing data values for channel A.
channelB - an array containing data values for channel B.
channelC - an array containing data values for channel C.
channelD - an array containing data values for channel D.
channelE - an array containing data values for channel E.
channelF - an array containing data values for channel F.
channelG - an array containing data values for channel G.
channelH - an array containing data values for channel H.

Notes:

- Channels not enabled or not supported by this device will be returned as an empty array.
- If using the PicoScope 4444, the values will be scaled according to the input range of the connected probe, otherwise values will be returned in millivolts. Use the getChannelInputRangeAndUnits() function to obtain the channel input range and units.

Please also refer to the ps4000aSetDataBuffer and ps4000aGetValues functions in the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps4000aGetTriggerTimeOffset</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, timeUpper, timeLower, timeUnits] = ps4000aGetTriggerTimeOffset(obj, segmentIndex)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    timeUpper = 0;
    timeLower = 0;
    timeUnits = 0;
    
    [status, timeUpper, timeLower, timeUnits] = calllib('ps4000a', ...
        'ps4000aGetTriggerTimeOffset', deviceObj.DriverData.unitHandle, ...
        timeUpper, timeLower, timeUnits, segmentIndex);
    
    if(status ~= PicoStatus.PICO_OK)
           
        error('ps4000aGetTriggerTimeOffset:- Status code: %d. Please refer to the PicoStatus.m file.', status); 
        
    end
</MCode>
               </Code>
               <Description>ps4000aGetTriggerTimeOffset(obj, segmentIndex) gets the time, as two 4-byte values, at which the trigger occurred.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Block group.
segmentIndex - the number of the memory segment for which the information is required.

Output parameters:

status - the status code returned by the driver.
timeUpper - the upper 32 bits of the time at which the trigger point occurred.
timeLower - the lower 32 bits of the time at which the trigger point occurred.
timeUnits - the time units in which timeUpper and timeLower are measured (represented by a PS4000A_TIME_UNITS enumeration).

For further information on the ps4000aGetTriggerTimeOffset function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps4000aGetTriggerTimeOffset64</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, time, timeUnits] = ps4000aGetTriggerTimeOffset64(obj, segmentIndex)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    time = 0;
    timeUnits = 0;

    [status, timeUnits] = calllib('ps4000a', ...
        'ps4000aGetTriggerTimeOffset64', deviceObj.DriverData.unithandle, ...
        time, timeUnits, segmentIndex);
    
    if(status ~= PicoStatus.PICO_OK)
           
        error('ps4000aGetTriggerTimeOffset64:- Status code: %d. Please refer to the PicoStatus.m file.', status);  
        
    end</MCode>
               </Code>
               <Description>ps4000aGetTriggerTimeOffset64(obj, segmentIndex)  gets the time, as a single 64-bit value, at which the trigger occurred.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Block group.
segmentIndex -  the number of the memory segment for which the information is required.

Output parameters:

status - the status code returned by the driver.
time - the time at which the trigger point occurred.
timeUnits - the time units in which time is measured (as an enumeration).

For further information on the ps4000aGetTriggerTimeOffset64 function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps4000aGetValues</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, numSamples, overflow] = ps4000aGetValues(obj, startIndex, noOfSamples, downSampleRatio, downSampleRatioMode, segmentIndex)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    pNumSamples = libpointer('uint32Ptr', noOfSamples);
    pOverflow = libpointer('int16Ptr', 0);
    
    [status] = calllib('ps4000a', 'ps4000aGetValues', ...
        deviceObj.DriverData.unitHandle, startIndex, pNumSamples, downSampleRatio, ....
        downSampleRatioMode, segmentIndex, pOverflow);
    
    if(status ~= PicoStatus.PICO_OK)
           
        error('ps4000aGetValues:- Status code: %d. Please refer to the PicoStatus.m file.', status);   
    
    else
        
        overflow = pOverflow.Value;
        numSamples = pNumSamples.Value;
        
    end</MCode>
               </Code>
               <Description>ps4000aGetValues(obj, startIndex, noOfSamples, downSampleRatio, downSampleRatioMode, segmentIndex) returns block-mode data, with or without downsampling, starting at the specified sample number.

Input parameters:

obj - the object representing the Block group.
startIndex - a zero-based index that indicates the start point for data collection.
noOfSamples - the number of samples required.
downSampleRatio - the downsampling factor that will be applied to the raw data.
downSampleRatioMode - which downsampling mode to use (specified by a PS4000A_RATIO_MODE enumeration).
segmentIndex - the zero-based number of the memory segment where the data is stored.

Output parameters:

status - the status code returned by the driver.
numSamples - the actual number retrieved from the driver.
overflow - a set of flags that indicate whether an overvoltage has occurred on any of the channels.

For further information on the ps4000aGetValues function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps4000aIsReady</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, ready] = ps4000aIsReady(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    ready = 0; % Initialise value for pointer
    
    [status, ready] = calllib('ps4000a', 'ps4000aIsReady', ...
                            deviceObj.DriverData.unitHandle, ready);

    if(status == PicoStatus.PICO_OK || status == PicoStatus.PICO_BUSY)

        % Do nothing

    else

        error('ps4000aIsReady:- Status code: %d. Please refer to the PicoStatus.m file.', status); 

    end</MCode>
               </Code>
               <Description>ps4000aIsReady(obj) indicates if the device has finished collecting the requested number of samples.

Use this function to poll the driver to indicate if block data collection has finished if using the ps4000aRunBlock function.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Block group.

Output parameters:

status - the status code returned by the driver.
ready - zero, the if device is still collecting. Non-zero, the device has finished collecting.

For further information on the ps4000aIsReady function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps4000aRunBlock</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, timeIndisposedMs] = ps4000aRunBlock(obj, segmentIndex)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    timeIndisposedMs = 0;   % Initialise to pass as pointer.
    lpReady = [];           % Set to NULL - Callback function not used.
    pParameter = [];        % Set to NULL - Callback function not used.
    
    unitHandle = deviceObj.DriverData.unitHandle;
    timebaseIndex = deviceObj.DriverData.timebase;
    preTriggerSamples = deviceObj.DriverData.numPreTriggerSamples;
    postTriggerSamples = deviceObj.DriverData.numPostTriggerSamples;
    
    if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
        
        fprintf('runBlock:- Collecting block of data:\n\tTimebase: %u\n\tPre-trigger samples: %u\n\tPost-trigger samples: %u\n', ...
            timebaseIndex, preTriggerSamples, postTriggerSamples);
        
    end

    [status, timeIndisposedMs] = calllib('ps4000a', 'ps4000aRunBlock', ...
        unitHandle, preTriggerSamples, postTriggerSamples, ...
        timebaseIndex, timeIndisposedMs, segmentIndex, lpReady, pParameter);
    
    if(status ~= PicoStatus.PICO_OK)
           
        error('ps4000aRunBlock:- Status code: %d. Please refer to the PicoStatus.m file.', status); 
        
    end
</MCode>
               </Code>
               <Description>ps4000aRunBlock(obj, segmentIndex) starts collecting data in block mode.

If additional code does not need to be called prior to the device indicating that it has collected data, use the runBlock function in place of this function.

This function can be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Block group.
segmentIndex - zero-based index, specifying which memory segment to use. Set this parameter to 0, if memory has not been segmented.

Output parameters:

status - the status code returned from the driver. 
timeIndisposedMs - the time in milliseconds, that the device will spend collecting samples.

For further information on the ps4000aRunBlock function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.





</Description>
            </Method>
            <Method>
               <Name>runBlock</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, timeIndisposedMs] = runBlock(obj, segmentIndex)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    timeIndisposedMs = 0;   % Initialise to pass as pointer.
    lpReady = [];           % Set to NULL - Callback function not used.
    pParameter = [];        % Set to NULL - Callback function not used.
    
    unitHandle = deviceObj.DriverData.unitHandle;
    timebaseIndex = deviceObj.DriverData.timebase;
    preTriggerSamples = deviceObj.DriverData.numPreTriggerSamples;
    postTriggerSamples = deviceObj.DriverData.numPostTriggerSamples;
    
    if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
        
        fprintf('runBlock:- Collecting block of data:\n\tTimebase: %u\n\tPre-trigger samples: %u\n\tPost-trigger samples: %u\n', ...
            timebaseIndex, preTriggerSamples, postTriggerSamples);

    end
    
    [runBlockStatus, timeIndisposedMs] = calllib('ps4000a', 'ps4000aRunBlock', ...
        unitHandle, preTriggerSamples, postTriggerSamples, ...
        timebaseIndex, timeIndisposedMs, segmentIndex, lpReady, pParameter);
    
    if(runBlockStatus ~= PicoStatus.PICO_OK)
           
        error('runBlock:- Error in ps4000aRunBlock call - code %d', runBlockStatus); 
        
    end
    
    if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
        
        fprintf('runBlock: Waiting for device to become ready...\n');
        
    end
    
    ready = 0; % Initialise value for pointer
    
    while(ready == 0)
        
        [readyStatus, ready] = calllib('ps4000a', 'ps4000aIsReady', ...
                                unitHandle, ready);
                        
        if(readyStatus == PicoStatus.PICO_OK || readyStatus == PicoStatus.PICO_BUSY)
           
            % Do nothing
            
        else
            
            error('runBlock: Error in ps4000aIsReady call - code %d', readyStatus); 
        
        end
                        
    end
    
    % Other conditions would have been captured.
    if(runBlockStatus == PicoStatus.PICO_OK &amp;&amp; readyStatus == PicoStatus.PICO_OK)
        
        status = PicoStatus.PICO_OK;
        
        if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
        
            fprintf('runBlock: Device ready.\n\n');
            
        end
        
    else
        
        if(runBlockStatus ~= PicoStatus.PICO_OK)
            
            error('runBlock:- ps4000aRunBlock error code: %d. Please refer to the PicoStatus.m file.', runBlockStatus);
            
        else
            
            error('runBlock:- ps4000aIsReady error code: %d. Please refer to the PicoStatus.m file.', readyStatus);
                
        end
            
        
    end;
    
    
    
</MCode>
               </Code>
               <Description>runBlock(obj, segmentIndex) starts collecting data in block mode and returns when the device is ready for data to be collected.

Input parameters:

obj - the object representing the Block group.
segmentIndex - zero-based index, specifying which memory segment to use. Set this parameter to 0, if memory has not been segmented.

Output parameters:

status - 0 if the ps4000aRunBlock and ps4000aIsReady functions have been executed correctly. 
timeIndisposedMs - the time in milliseconds, that the device will spend collecting samples.

For further information on the ps4000aRunBlock and ps4000aIsReady functions please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.
</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>rapidblock</Name>
         <Description>The Rapidblock group contains a set of properties and functions related to the rapid block data capture functionality of the device.</Description>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="rapidblock" Index="1"/>
         </Mappings>
         <PropertyInfo/>
         <MethodInfo>
            <Method>
               <Name>getRapidBlockData</Name>
               <Location>rapidblock</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [numSamples, overflow, channelA, channelB, channelC, channelD, channelE, channelF, channelG, channelH] = getRapidBlockData(obj, numCaptures, ratio, ratioMode)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    % Check ratio mode is not aggregated
    if (ratioMode ~= deviceObj.DriverData.enums.enPS4000ARatioMode.PS4000A_RATIO_MODE_AGGREGATE)
        
        unitHandle = deviceObj.DriverData.unitHandle;
        
        channelCount = deviceObj.DriverData.channelCount;
        
        % Retrieve channel settings - channel x data field matrix
        channelSettings = deviceObj.DriverData.channelSettings; 
        
        % Create empty arrays for channel data.
        channelA = [];
        channelB = [];
        channelC = [];
        channelD = [];
        channelE = [];
        channelF = [];
        channelG = [];
        channelH = [];

        % Initialise variable for array of libpointers
        pBuffer(channelCount, numCaptures) = libpointer;
        
        % Initialise array for status values
        setBufferStatus = zeros(channelCount, numCaptures, 'uint32');

        % total number of samples to set for data buffers
        totalSamples = deviceObj.DriverData.numPreTriggerSamples + deviceObj.DriverData.numPostTriggerSamples;
        
        % Create a 2D matrix of libpointers to allocate memory space for
        % each channel and segment combination
        for segment = 1:numCaptures
            
            for ch = 1:channelCount
                
                % Set Data Buffer if channel is enabled
                if(channelSettings(ch, 1) == PicoConstants.TRUE)
                    
                    % Store array of libpointers
                    pBuffer(ch, segment) = libpointer('int16Ptr', zeros(totalSamples, 1, 'int16'));
                    
                    setBufferStatus(ch, segment) = calllib('ps4000a', 'ps4000aSetDataBuffer', ...
                        unitHandle, (ch - 1), pBuffer(ch, segment), totalSamples, ...
                        (segment - 1), ratioMode);

                    if(setBufferStatus(ch, segment) ~= PicoStatus.PICO_OK)

                        error('getRapidBlockData: Set Data Buffer for Channel %d Segment % error code %d', ...
                            (ch - 1), (segment - 1), setBufferStatus);

                    end
                    
                end
                
            end

        end

        if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
            
            fprintf('getRapidBlockData: Retrieving data...\n');
            
        end
        
        fromSegmentIndex = 0;
        toSegmentIndex = numCaptures - 1;

        overflowSize = (toSegmentIndex - fromSegmentIndex) + 1;
        overflowPtr = libpointer('int16Ptr', zeros(overflowSize, 1, 'int16'));
        overflow = 0;
        
        [getValuesBulkStatus, numSamples] = calllib('ps4000a', ...
            'ps4000aGetValuesBulk', unitHandle, totalSamples, fromSegmentIndex, ...
            toSegmentIndex, ratio, ratioMode, overflowPtr);
        
        overflow = overflowPtr.Value;
        
        if (getValuesBulkStatus == PicoStatus.PICO_OK)
            
            if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
                
                fprintf('getRapidBlockData: Converting ADC counts and assigning to channel array.\n');
                
            end
            
            % Obtain max ADC count value
            maxADCValue = double(deviceObj.DriverData.maxADCValue);
            
            % Retrieve data values for enabled channels
            for ch = 1:channelCount

                if (channelSettings(ch,1) == PicoConstants.TRUE)
                    
                    % Obtain the probe input range for the channel.
                    [channelInputRange, ~] = invoke(deviceObj, 'getChannelInputRangeAndUnits', (ch - 1));
                    
                    % Obtain a cell array representing the waveforms for 
                    % the channel
                    
                    bufferCell = get(pBuffer(ch, :), 'Value');
                    
                    % Combine the cell contents into a total_samples x
                    % numCaptures array
                    
                    bufferMatrix = [];
                    
                    if (numCaptures &gt; 1)
                        
                        bufferMatrix = horzcat(bufferCell{1:end});
                        
                    else
                       
                        bufferMatrix = bufferCell;
                        
                    end
                   
                    bufferValues = adc2mv(bufferMatrix, channelInputRange, maxADCValue);
                    
                    switch (ch - 1)

                        case deviceObj.DriverData.enums.enPS4000AChannel.PS4000A_CHANNEL_A

                            channelA = bufferValues;

                        case deviceObj.DriverData.enums.enPS4000AChannel.PS4000A_CHANNEL_B

                            channelB = bufferValues;

                        case deviceObj.DriverData.enums.enPS4000AChannel.PS4000A_CHANNEL_C

                            channelC = bufferValues;

                        case deviceObj.DriverData.enums.enPS4000AChannel.PS4000A_CHANNEL_D

                            channelD = bufferValues;
                            
                        case deviceObj.DriverData.enums.enPS4000AChannel.PS4000A_CHANNEL_E

                            channelE = bufferValues;

                        case deviceObj.DriverData.enums.enPS4000AChannel.PS4000A_CHANNEL_F

                            channelF = bufferValues;

                        case deviceObj.DriverData.enums.enPS4000AChannel.PS4000A_CHANNEL_G

                            channelG = bufferValues;

                        case deviceObj.DriverData.enums.enPS4000AChannel.PS4000A_CHANNEL_H

                            channelH = bufferValues;

                        otherwise

                            % Do nothing

                    end
                    
                    clear bufferCell;
                    clear bufferMatrix;
                    clear bufferValues;
                    
                end
                
            end
            
            if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
                
                fprintf('getRapidBlockData: Data succesfully retrieved.\n\n');
                
            end
            
            clear pBuffer;
            
        else
            
            error('getRapidBlockData:- Error retrieving data values - code: %d. Please refer to the PicoStatus.m file.', getValuesBulkStatus);
            
        end
        
        
    else
        
        error('getRapidBlockData: Aggregate Mode data collection not supported by this function.');
        
    end</MCode>
               </Code>
               <Description>getRapidBlockData(obj, numCaptures, ratio, ratioMode) retrieves waveforms captured using rapid block mode. The waveforms must have been collected sequentially and in the same run.

Memory for the data arrays from segment index 0 to numCaptures - 1 is allocated and the driver is informed where to store the data prior to retrieval. Data collection in Aggregation mode or with more than one downsampling mode  is NOT supported by this function.

This function can be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Rapidblock group.
numCaptures - the number of waveform captures to retrieve.
ratio - the downsampling factor that will be applied to the raw data.
ratioMode - which downsampling mode to use (specified by enumeration from the PS4000A_RATIO_MODE set excluding PS4000A_RATIO_MODE_AGGREGATE).

Output parameters:

status - the status code returned by the driver.
numSamples - the number of samples retrieved from the driver.
overflow - a set of flags that indicate whether an overvoltage has occurred on any of the channels.
channelA - a matrix containing data values for channel A.
channelB - a matrix containing data values for channel B.
channelC - a matrix containing data values for channel C.
channelD - a matrix containing data values for channel D.
channelE - a matrix containing data values for channel E.
channelF - a matrix containing data values for channel F.
channelG - a matrix containing data values for channel G.
channelH - a matrix containing data values for channel H.

Notes:

- Channel data will be returned as an array in the form numSamples x numCaptures. Channels not enabled or not supported by this device will be returned as an empty array.
- If using the PicoScope 4444, the values will be scaled according to the input range of the connected probe, otherwise values will be returned in millivolts. Use the getChannelInputRangeAndUnits() function to obtain the channel input range and units.

Please also refer to the  ps4000aSetDataBuffer and ps4000aGetValues functions as well as the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps4000aGetNoOfCaptures</Name>
               <Location>rapidblock</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, nCaptures] = ps4000aGetNoOfCaptures(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    unitHandle = deviceObj.DriverData.unitHandle;
    
    nCaptures = 0; % Value for pointer.

    [status, nCaptures] = calllib('ps4000a', 'ps4000aGetNoOfCaptures', ...
                            unitHandle, nCaptures);
                        
    if(status ~= PicoStatus.PICO_OK)
           
        error('ps4000aGetNoOfCaptures:- Status code: %d. Please refer to the PicoStatus.m file.', status); 
        
    end
</MCode>
               </Code>
               <Description>ps4000aGetNoOfCaptures(obj) finds out how many captures are available in rapid block mode after runBlock has been called when either the collection completed or the collection of waveforms was interrupted by calling ps4000aStop.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Rapidblock group.

Output parameters:

status - the status code returned by the driver.
nCaptures - the number of available captures that has been collected from calling runBlock.

For further information on the ps4000aGetNoOfCaptures function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps4000aGetNoOfProcessedCaptures</Name>
               <Location>rapidblock</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, nProcessedCaptures] = ps4000aGetNoOfProcessedCaptures(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    unitHandle = deviceObj.DriverData.unitHandle;
    
    nProcessedCaptures = 0;

    [status, nProcessedCaptures] = calllib('ps4000a', 'ps4000aGetNoOfProcessedCaptures', ...
        unitHandle, nProcessedCaptures);
    
    if(status ~= PicoStatus.PICO_OK)
           
        error('ps4000aGetNoOfProcessedCaptures:- Status code: %d. Please refer to the PicoStatus.m file.', status);  
        
    end
</MCode>
               </Code>
               <Description>ps4000aGetNoOfProcessedCaptures(obj, nCaptures) finds out how many captures in rapid block mode have been processed after runBlock has been called when either the collection completed or the collection of waveforms was interrupted by calling ps4000aStop.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Rapidblock group.

Output parameters:

status - the status code returned by the driver.
nProcessedCaptures - the number of available captures that has been collected from calling runBlock.

For further information on the ps4000aGetNoOfProcessedCaptures function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps4000aGetValuesBulk</Name>
               <Location>rapidblock</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, numSamples, overflow] = ps4000aGetValuesBulk(obj, noOfSamples, fromSegmentIndex, toSegmentIndex, downSampleRatio, downSampleRatioMode)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    unitHandle = deviceObj.DriverData.unitHandle;

    % overflow must be an array
    overflowSize = (toSegmentIndex - fromSegmentIndex) + 1;
    overflowPtr = libpointer('int16Ptr', zeros(overflowSize, 1));
    overflow = 0;

    [status, numSamples] = calllib('ps4000a', 'ps4000aGetValuesBulk', ...
        unitHandle, noOfSamples, fromSegmentIndex, toSegmentIndex, ... 
        downSampleRatio, downSampleRatioMode, overflowPtr);
    
    if(status == PicoStatus.PICO_OK)
        
        overflow = get(overflowPtr, 'Value');
        
    else
           
        error('ps4000aGetValuesBulk:- Status code: %d. Please refer to the PicoStatus.m file.', status); 
        
    end</MCode>
               </Code>
               <Description>ps4000aGetValuesBlk(obj, noOfSamples, fromSegmentIndex, toSegmentIndex, downSampleRatio, downSampleRatioMode) retrieves waveforms captured using rapid block mode.

Input parameters:

obj - the object representing the Rapidblock group.
noOfSamples - the number of samples required.
fromSegmentIndex - the first segment from which the waveform should be retrieved.
toSegmentIndex - the last segment from which the waveform should be retrieved.
downSampleRatio - the downsampling factor that will be applied to the raw data.
downSampleRatioMode - which downsampling mode to use (specified by a PS4000A_RATIO_MODE enumeration value).

Output parameters:

status - the status code returned by the driver.
numSamples - the actual number retrieved from the driver.
overflow - an array of integers equal to or larger than the number of waveforms to be retrieved with each element corresponding to an overlow value as described in the ps4000aGetValues function.

For further information on the ps4000aGetValuesBulk function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps4000aSetNoOfCaptures</Name>
               <Location>rapidblock</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps4000aSetNoOfCaptures(obj, nCaptures)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    unitHandle = deviceObj.DriverData.unitHandle;

    status = calllib('ps4000a', 'ps4000aSetNoOfCaptures', ...
        unitHandle', nCaptures);
    
    if(status ~= PicoStatus.PICO_OK)
           
        error('ps4000aSetNoOfCaptures:- Status code: %d. Please refer to the PicoStatus.m file.', status);  
        
    end</MCode>
               </Code>
               <Description>ps4000aSetNoOfCaptures(obj, nCaptures) sets the number of captures to be collected in one run of rapid block mode.

If this function is not called prior to a run, only a single waveform will be captured.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Rapidblock group.
nCaptures - the number of waveforms to capture in one run.

Output parameters:

status - the status code returned by the device.

For further information on the ps4000aSetNoOfCaptures function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>signalgenerator</Name>
         <Description>The Signalgenerator group contains a set of properties and functions related to the signal generator functionality of the device.</Description>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="signalgenerator" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>awgBufferSize</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.awgBufferSize;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="16384.0" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>The size of the arbitrary waveform buffer on the device, in samples.</Description>
            </Property>
            <Property>
               <Name>dacFrequency</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.dacFrequency;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="8.0E7" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>80E6</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>The update frequency of the Arbitrary Waveform Generator (MS/s or MHz).</Description>
            </Property>
            <Property>
               <Name>offsetVoltage</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.offsetVoltage;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    deviceObj.DriverData.offsetVoltage = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="2000.0" Min="-2000.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The voltage offset, in milliVolts, to be applied to the waveform.

The sum of the offset voltage and peak to peak voltage should not exceed +/- 4000mV.</Description>
            </Property>
            <Property>
               <Name>peakToPeakVoltage</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.peakToPeakVoltage;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    deviceObj.DriverData.peakToPeakVoltage = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="4000.0" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>2000</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The peak-to-peak voltage, in millivolts, of the waveform signal.

The sum of the peak to peak voltage and offset voltage should not exceed +/- 4000mV.</Description>
            </Property>
            <Property>
               <Name>sigGenType</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.sigGenType;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                     <Value>2.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0.0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>The type of Signal Generator on the device:

0 - None
1 - Function Generator
2 - Arbitrary Waveform Generator</Description>
            </Property>
            <Property>
               <Name>startFrequency</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.startFrequency;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    deviceObj.DriverData.startFrequency = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="1000000.0" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>1000</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The frequency that the signal generator will initially produce (Hertz).</Description>
            </Property>
            <Property>
               <Name>stopFrequency</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.stopFrequency;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    deviceObj.DriverData.stopFrequency = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="1000000.0" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>1000</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The frequency at which the sweep reverses direction or returns to the initial frequency (Hertz).

To output a signal with constant frequency, ensure that stopFrequency is equal to startFrequency.</Description>
            </Property>
         </PropertyInfo>
         <MethodInfo>
            <Method>
               <Name>ps4000aSigGenSoftwareControl</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps4000aSigGenSoftwareControl(obj, state)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    status = calllib('ps4000a', 'ps4000aSigGenSoftwareControl', ...
                deviceObj.DriverData.unitHandle, state);
            
	if(status ~= PicoStatus.PICO_OK)
           
        error('ps4000aSigGenSoftwareControl:- Status code: %d. Please refer to the PicoStatus.m file.', status);
        
    end </MCode>
               </Code>
               <Description>ps4000aSigGenSoftwareControl(obj, state) causes a trigger event, or starts and stops gating.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Signalgenerator group.
state - sets the trigger gate high or low when the trigger type is set to either SIGGEN_GATE_HIGH or SIGGEN_GATE_LOW.

Output parameters:

status - the status code returned by the driver.

For further information on the ps4000aSigGenSoftwareControl function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>setSigGenArbitrary</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, dwellTime] = setSigGenArbitrary(obj, increment, dwellTime, arbitraryWaveform, sweepType, operation, indexMode, shots, sweeps, triggerType, triggerSource, extInThresholdMV)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    % Only call function if device has an Arbitrary Waveform Generator
    if(get(obj, 'sigGenType') == PicoConstants.SIG_GEN_AWG)

        offsetVoltageUV = deviceObj.DriverData.offsetVoltage * 1e3;
        peakToPeakVoltageUV = deviceObj.DriverData.peakToPeakVoltage * 1e3;
        
        if(abs(offsetVoltageUV + peakToPeakVoltageUV) &gt; 4000000)
            
            error('setSigGenBuiltInSimple: The sum of offsetVoltage and peakToPeakVoltage cannot exceed +/-4000mV.');
            
        end
        
        dacFrequency = get(obj, 'dacFrequency');
        
        % Convert the waveform to the range for the driver
        arbitraryWave = int16(arbitraryWaveform * double(intmax('int16')));    
      
        startFrequency = get(obj, 'startFrequency');
        
        startDeltaPhase = 0;       
             
        [status, startDeltaPhase] = calllib('ps4000a', 'ps4000aSigGenFrequencyToPhase', ...
                                  deviceObj.DriverData.unitHandle, ...
                                  startFrequency, indexMode, ...
                                  length(arbitraryWave),startDeltaPhase); 
                    
        stopDeltaPhase = 0;

        dwellCount = 0;

        % No need to calculate stop delta phase if start and stop frequencies
        % are the same.
        
        stopFrequency = get(obj, 'stopFrequency');
        
        if(stopFrequency == startFrequency)

            stopDeltaPhase = startDeltaPhase;

        else

            [status, stopDeltaPhase] = calllib('ps4000a', 'ps4000aSigGenFrequencyToPhase', ...
                                  deviceObj.DriverData.unitHandle, ...
                                  stopFrequency, indexMode, ...
                                  length(arbitraryWave),stopDeltaPhase); 

        end

        %fprintf('setSigGenArbitrary:Stop delta phase: %d\n', stop_delta_phase);
        deltaPhaseIncrement = 0;
        
        [status, deltaPhaseIncrement] = calllib('ps4000a', 'ps4000aSigGenFrequencyToPhase', ...
                                  deviceObj.DriverData.unitHandle, ...
                                  increment, indexMode, ...
                                  length(arbitraryWave),deltaPhaseIncrement); 
            
        %fprintf('setSigGenArbitrary:Delta phase increment: %d\n', delta_phase_increment);

        dwellCount = round(dwellTime * dacFrequency); % Round to the nearest integer
        
        %fprintf('setSigGenArbitrary:Dwell count: %d\n', dwell_count);

        if(dwellCount &lt; PS4000aConstants.PS4000A_MIN_DWELL_COUNT)

            dwellCount = PS4000aConstants.PS4000A_MIN_DWELL_COUNT;

        end
        
        % Return dwell time information to the user if it has been
        % modified.
        dwellTime = dwellCount / dacFrequency;
        
        %fprintf('setSigGenArbitrary:Dwell time: %d\n', dwell_time);
        
        % No external trigger for PicoScope 4824
        extInThreshold = 0;

        status = calllib('ps4000a', 'ps4000aSetSigGenArbitrary', ...
                    deviceObj.DriverData.unitHandle, ...
                    offsetVoltageUV, peakToPeakVoltageUV, startDeltaPhase, ...
                    stopDeltaPhase, deltaPhaseIncrement, dwellCount, arbitraryWave, ...
                    length(arbitraryWave), sweepType, operation, indexMode, shots, ...
                    sweeps, triggerType, triggerSource, extInThreshold);
         
        % Output error message to user if status is not PICO_OK        
        if(status ~= PicoStatus.PICO_OK)
                    
            switch(status)

                case PicoStatus.PICO_SIG_GEN_PARAM
                    
                    error('setSigGenArbitrary: Incorrect parameter passed to the signal generator.');
                    
                case PicoStatus.PICO_SHOTS_SWEEPS_WARNING
                    
                    error('setSigGenArbitrary: Incorrect parameter passed to the signal generator.');
                    
                case PicoStatus.PICO_SIGGEN_OUTPUT_OVER_VOLTAGE
                    
                    error('setSigGenArbitrary: The combined peak to peak voltage and the analog offset voltage must be in the range 0 -&gt; +/- 2V');
                   
                case PicoStatus.PICO_WARNING_EXT_THRESHOLD_CONFLICT
                    
                    error('setSigGenArbitrary: Attempt to set different EXT input thresholds set for signal generator and oscilloscope trigger.');
                    
                case PicoStatus.PICO_SIGGEN_OFFSET_VOLTAGE
                    
                    error('setSigGenArbitrary: The analog offset voltage is out of range.');

                case PicoStatus.PICO_SIGGEN_PK_TO_PK
                    
                    error('setSigGenArbitrary: The analog peak to peak voltage must be in the range 0 -&gt; +/- 2V.');
                    
                case PicoStatus.PICO_SIGGEN_WAVEFORM_SETUP_FAILED
                    
                    error('setSigGenArbitrary: Unable to setup signal generator waveform.');
                    
                otherwise     
                    
                    error('setSigGenArbitrary:- Status code: %d. Please refer to the PicoStatus.m file.', status);
            end
            
        end
        
        clear offsetVoltageUV
        clear peakToPeakVoltageUV
        clear maxBufferSize
        clear dacFrequency
        clear arbitraryWave
        clear startDeltaPhase
        clear stopDeltaPhase
        clear dwellCount
        clear deltaPhaseIncrement
        clear startFrequency;
        clear stopFrequency;
                
    else
       
        error('AWG functionality not supported by this device.');
        
    end</MCode>
               </Code>
               <Description>setSigGenArbitrary(obj, increment, dwellTime, arbitraryWaveform, sweepType, operation, indexMode, shots, sweeps, triggerType, triggerSource, extInThreshold) programs the signal generator to produce an arbitrary waveform.

The startFrequency, stopFrequency, offsetVoltage and peakToPeakVoltage properties must be set prior to calling this function, otherwise the default values will be used.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Signalgenerator group.
increment - the increase or decrease in frequency when operating in sweep mode.
dwellTime - the time for which the sweep stays at each frequency, in seconds.
arbitraryWaveform -  a buffer that holds the waveform pattern as a set of samples in the range -1 to +1. These values correspond to the maximum and minimum amplitude values of the waveform.
sweepType -  determines whether the startFrequency is swept up to the stopFrequency, or down to it, or repeatedly up and down.
operation - configures the white noise/PRBS (pseudo-random binary sequence) generator.
indexMode - specifies how the signal will be formed from the arbitrary waveform data.
shots - the number of cycles of the waveform to be produced after a trigger event. If this is set to a non-zero value 
	then sweeps must be set to zero.
sweeps - the number of times to sweep the frequency after a trigger event, according to sweepType. If this is set to a non-zero value 
		then shots must be set to zero.
triggerType - the type of trigger that will be applied to the signal generator.
triggerSource - the source that will trigger the signal generator.
extInThresholdMV - not used by the PicoScope 4824

Output parameters:

status - the status code returned by the driver.
dwellTime -  the dwell time will be modified if the user specifies a dwell time (125e-9) corresponding to less than the minimum dwell count for the device (10).

For further information on the ps4000aSetSigGenArbitrary function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes.




 </Description>
            </Method>
            <Method>
               <Name>setSigGenArbitrarySimple</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setSigGenArbitrarySimple(obj, arbitraryWaveform)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    % Only call function if device has an Arbitrary Waveform Generator
    if(get(obj, 'sigGenType') == PicoConstants.SIG_GEN_AWG)

        % Convert voltages to microvolts
        offsetVoltageUV = deviceObj.DriverData.offsetVoltage * 1e3;
        peakToPeakVoltageUV = deviceObj.DriverData.peakToPeakVoltage * 1e3;
        
        if(abs(offsetVoltageUV + peakToPeakVoltageUV) &gt; 4000000)
            
            error('setSigGenBuiltInSimple: The sum of offsetVoltage and peakToPeakVoltage cannot exceed +/-4000mV.');
            
        end
        
        dacFrequency = get(obj, 'dacFrequency');
        
        % Convert the waveform to the range for the driver
        arbitraryWave = int16(arbitraryWaveform * double(intmax('int16')));

        startDeltaPhase = 0;
        
        single =  deviceObj.DriverData.enums.enPS4000AIndexMode.PS4000A_SINGLE;
        
        [status, startDeltaPhase] = calllib('ps4000a', 'ps4000aSigGenFrequencyToPhase', ...
                                  deviceObj.DriverData.unitHandle, ...
                                  get(obj, 'startFrequency'), single, ...
                                  length(arbitraryWave),startDeltaPhase); 

        % Constant frequency
        stopDeltaPhase = startDeltaPhase;
        
        status = calllib('ps4000a', 'ps4000aSetSigGenArbitrary', ...
                    deviceObj.DriverData.unitHandle, offsetVoltageUV, ...
                    peakToPeakVoltageUV, startDeltaPhase, ...
                    stopDeltaPhase, 0, 0, arbitraryWave, ...
                    length(arbitraryWave), 0, 0, 0, 0, 0, 0, 0, 0);
         
        % Output error message to user if status is not PICO_OK        
        if(status ~= PicoStatus.PICO_OK)
                    
            switch(status)

                case PicoStatus.PICO_SIG_GEN_PARAM
                    
                    error('setSigGenArbitrary: Incorrect parameter passed to the signal generator.');
                    
                case PicoStatus.PICO_SHOTS_SWEEPS_WARNING
                    
                    error('setSigGenArbitrary: Incorrect parameter passed to the signal generator.');
                    
                case PicoStatus.PICO_SIGGEN_OUTPUT_OVER_VOLTAGE
                    
                    error('setSigGenArbitrary: The combined peak to peak voltage and the analog offset voltage must be in the range 0 -&gt; +/- 2V');
                   
                case PicoStatus.PICO_WARNING_EXT_THRESHOLD_CONFLICT
                    
                    error('setSigGenArbitrary: Attempt to set different EXT input thresholds set for signal generator and oscilloscope trigger.');
                    
                case PicoStatus.PICO_SIGGEN_OFFSET_VOLTAGE
                    
                    error('setSigGenArbitrary: The analog offset voltage is out of range.');

                case PicoStatus.PICO_SIGGEN_PK_TO_PK
                    
                    error('setSigGenArbitrary: The analog peak to peak voltage must be in the range 0 -&gt; +/- 2V.');
                    
                case PicoStatus.PICO_SIGGEN_WAVEFORM_SETUP_FAILED
                    
                    error('setSigGenArbitrary: Unable to setup signal generator waveform.');
                    
                otherwise     
                    
                    error('setSigGenArbitrarySimple:- Status code: %d. Please refer to the PicoStatus.m file.', status);
            end
            
        end
                
    else
       
        error('AWG functionality not supported by this device.');
        
    end


</MCode>
               </Code>
               <Description>setSigGenArbitrary(obj, arbitraryWaveform) programs the signal generator to produce an arbitrary waveform at a constant frequency.

The startFrequency, stopFrequency, offsetVoltage and peakToPeakVoltage properties must be set prior to calling this function, otherwise the default values will be used.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Signalgenerator group.
arbitraryWaveform -  a buffer that holds the waveform pattern as a set of samples in the range -1 to +1. These values correspond to the 	maximum and minimum amplitude values of the waveform.

Output parameters:

status - the status code returned by the driver.

For further information on the ps4000aSetSigGenArbitrary function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>setSigGenBuiltIn</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setSigGenBuiltIn(obj, waveType, increment, dwellTime, sweepType, operation, shots, sweeps, triggerType, triggerSource, extInThresholdMV)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
    
    deviceObj = get(obj, 'Parent');
    sigGenType = get(obj, 'sigGenType');
    
    % Error checking
    if(sigGenType == PicoConstants.SIG_GEN_AWG || ...
            sigGenType == PicoConstants.SIG_GEN_FUNCT_GEN)
        
        % Convert millivolt values to microvolts  
        offsetVoltageUV = deviceObj.DriverData.offsetVoltage * 1e3;
        peakToPeakVoltageUV = deviceObj.DriverData.peakToPeakVoltage * 1e3;
        
        if(abs(offsetVoltageUV + peakToPeakVoltageUV) &gt; 4000000)
            
            error('setSigGenBuiltInSimple: The sum of offsetVoltage and peakToPeakVoltage cannot exceed +/-4000mV.');
            
        end
        
        % External trigger not used
        extInThreshold = 0;

        status = calllib('ps4000a', 'ps4000aSetSigGenBuiltIn', deviceObj.DriverData.unitHandle, ...
                    offsetVoltageUV, peakToPeakVoltageUV, waveType, ...
                    deviceObj.DriverData.startFrequency, deviceObj.DriverData.stopFrequency, ...
                    increment, dwellTime, sweepType, operation, shots, sweeps, ...
                    triggerType, triggerSource, extInThreshold);

        % Output error message to user if status is not PICO_OK        
        if(status ~= PicoStatus.PICO_OK)

            switch(status)

                case PicoStatus.PICO_SIG_GEN_PARAM

                    error('setSigGenBuiltIn: One or more signal generator parameters are out of range.');

                case PicoStatus.PICO_SHOTS_SWEEPS_WARNING

                    error('setSigGenBuiltIn: Shots/sweeps warning.');

                case PicoStatus.PICO_SIGGEN_OUTPUT_OVER_VOLTAGE

                    error('setSigGenBuiltIn: The combined peak to peak voltage and the analog offset voltage must be in the range 0 -&gt; +/- 2V');

                case PicoStatus.PICO_SIGGEN_OFFSET_VOLTAGE

                    error('setSigGenBuiltIn: The analog offset voltage is out of range.');

                case PicoStatus.PICO_SIGGEN_PK_TO_PK

                    error('setSigGenBuiltIn: The analog peak to peak voltage must be in the range 0 -&gt; +/- 2V.');

                case PicoStatus.PICO_SIGGEN_WAVEFORM_SETUP_FAILED

                    error('setSigGenBuiltIn: Unable to setup signal generator waveform.');

                otherwise     

                    error('setSigGenBuiltIn:- Status code: %d. Please refer to the PicoStatus.m file.', status);
            end

        end
        
        clear offsetVoltage;
        clear peakToPeakVoltage;
        clear sigGenType;
            
    else
        
        error('setSigGenBuiltIn: Signal Generator functionality not supported by this device.');
        
    end</MCode>
               </Code>
               <Description>setSigGenBuiltIn(obj, waveType, increment, dwellTime, sweepType, operation, shots, sweeps, triggerType, triggerSource, extInThresholdMV) sets up the signal generator to produce a signal from a list of built-in waveforms.

The startFrequency, stopFrequency, offsetVoltage and peakToPeakVoltage properties must be set prior to calling this function otherwise the default values will be used.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Signalgenerator group.
wavetype - the type of waveform to be generated by the oscilloscope. Use the following waveType enumerations:

		0 - SINE
		1 - SQUARE
		2 - TRIANGLE
		3 - RAMP UP
		4 - RAMP DOWN
		5 - SINC
		6 - GAUSSIAN
		7 - HALF SINE
		8 - DC VOLTAGE
		9 - WHITE NOISE

increment - the amount in hertz by which the frequency rises or falls every dwellTime seconds in sweep mode.
dwellTime - the time in seconds between frequency changes in sweep mode.
sweepType - determines whether the startFrequency is swept up to the stopFrequency, or down to it, or repeatedly up and down.
operation - configures the white noise/PRBS (pseudo-random binary sequence) generator.
shots - the number of cycles of the waveform to be produced after a trigger event. If this is set to a non-zero value 
		then sweeps must be set to zero.
sweeps - the number of times to sweep the frequency after a trigger event, according to sweepType. If this is set to a non-zero value then shots must be set to zero.
triggerType - the type of trigger that will be applied to the signal generator.
triggerSource - the source that will trigger the signal generator.
extInThresholdMV - not used by the PicoScope 4824

Output parameters:

status -  thestatus code returned by the driver.

For further information on the ps4000aSetSigGenBuiltIn function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.

</Description>
            </Method>
            <Method>
               <Name>setSigGenBuiltInSimple</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setSigGenBuiltInSimple(obj, waveType)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
 
    deviceObj = get(obj, 'Parent');
    sigGenType = get(obj, 'sigGenType');
    
    % Error checking
    if(sigGenType == PicoConstants.SIG_GEN_AWG || ...
            sigGenType == PicoConstants.SIG_GEN_FUNCT_GEN)
        
        % Convert millivolt values to microvolts  
        offsetVoltageUV = deviceObj.DriverData.offsetVoltage * 1e3;
        peakToPeakVoltageUV = deviceObj.DriverData.peakToPeakVoltage * 1e3;
        
        if(abs(offsetVoltageUV + peakToPeakVoltageUV) &gt; 4000000)
            
            error('setSigGenBuiltInSimple: The sum of offsetVoltage and peakToPeakVoltage cannot exceed +/-4000mV.');
            
        end
        
        status = calllib('ps4000a', 'ps4000aSetSigGenBuiltIn', deviceObj.DriverData.unitHandle, ...
                    offsetVoltageUV, peakToPeakVoltageUV, waveType, ...
                    deviceObj.DriverData.startFrequency, deviceObj.DriverData.startFrequency, ...
                        0, 0, 0, 0, 0, 0, 0, 0, 0);
                    
        % Output error message to user if status is not PICO_OK        
        if(status ~= PicoStatus.PICO_OK)

            switch(status)

                case PicoStatus.PICO_SIG_GEN_PARAM

                    error('setSigGenBuiltInSimple: One or more signal generator parameters are out of range.');

                case PicoStatus.PICO_SHOTS_SWEEPS_WARNING

                    error('setSigGenBuiltInSimple: Shots/sweeps warning.');

                case PicoStatus.PICO_SIGGEN_OUTPUT_OVER_VOLTAGE

                    error('setSigGenBuiltInSimple: The combined peak to peak voltage and the analog offset voltage must be in the range 0 -&gt; +/- 2V');

                case PicoStatus.PICO_WARNING_EXT_THRESHOLD_CONFLICT

                    error('setSigGenBuiltInSimple: External threshold conflict.');

                case PicoStatus.PICO_SIGGEN_OFFSET_VOLTAGE

                    error('setSigGenBuiltInSimple: The analog offset voltage is out of range.');

                case PicoStatus.PICO_SIGGEN_PK_TO_PK

                    error('setSigGenBuiltInSimple: The analog peak to peak voltage must be in the range 0 -&gt; +/- 2V.');

                case PicoStatus.PICO_SIGGEN_WAVEFORM_SETUP_FAILED

                    error('setSigGenBuiltInSimple: Unable to setup signal generator waveform.');

                otherwise     

                    error('setSigGenBuiltInSimple:- Status code: %d. Please refer to the PicoStatus.m file.', status);
            end

        end  
        
        clear offsetVoltageUV;
        clear peakToPeakVoltageUV;
        clear sigGenType;
    
    else
        
        error('setSigGenBuiltInSimple: Signal Generator functionality not supported by this device.');
        
    end
</MCode>
               </Code>
               <Description>setSigGenBuiltInSimple(obj, offsetVoltageMV, pkToPkMV, waveType) sets up the signal generator to produce a signal of constant frequency from a list of built-in waveforms.

The startFrequency, offsetVoltage and peakToPeakVoltage properties must be set prior to using this function, or the default values will be used.

The offset voltage offsetVoltage and peakToPeakVoltage properties are defined in millivolts and converted to microvolts for the underlying driver. The sum of offsetVoltageMV and pkToPkMV cannot exceed 4000 millivolts.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Signalgenerator group.
wavetype - the type of waveform to be generated by the oscilloscope. Use the following waveType enumerations:

		0 - SINE
		1 - SQUARE
		2 - TRIANGLE
		3 - RAMP UP
		4 - RAMP DOWN
		5 - SINC
		6 - GAUSSIAN
		7 - HALF SINE
		8 - DC VOLTAGE
		9 - WHITE NOISE

Output parameters:

status - the status code returned by the driver.

For further information, please view the Help text for the ps4000aSetSigGenBuiltIn function.
</Description>
            </Method>
            <Method>
               <Name>setSigGenOff</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setSigGenOff(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    offsetVoltage = 0;
    pkToPk = 0;
    waveTypeDC = deviceObj.DriverData.enums.enPS4000AWaveType.PS4000A_DC_VOLTAGE;
    
    
    status = calllib('ps4000a', 'ps4000aSetSigGenBuiltIn', ...
                deviceObj.DriverData.unitHandle, ...
                offsetVoltage, pkToPk, waveTypeDC, 0, 0, ...
                0, 0, 0, 0, 0, 0, 0, 0, 0);
                    
    if(status ~= PicoStatus.PICO_OK)
       
        error('setSigGenOff:- Status code: %d. Please refer to the PicoStatus.m file.', status);
        
    end
            
	clear offsetVoltage;
    clear pkToPk;
    clear waveTypeDC;</MCode>
               </Code>
               <Description>setSigGenOff(obj) effectively turns off the signal generator by setting the output to a zero DC voltage.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Signalgenerator group.

Output parameters:

status - the status code returned by the driver.</Description>
            </Method>
            <Method>
               <Name>setSigGenPropertiesArbitrary</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, dwellTime] = setSigGenPropertiesArbitrary(obj, increment, dwellTime, sweepType, shots, sweeps, triggerType, triggerSource, extInThresholdMV)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    % Only call function if device has an Arbitrary Waveform Generator
    if(get(obj, 'sigGenType') == PicoConstants.SIG_GEN_AWG)
        
        maxBufferSize = get(obj, 'awgBufferSize');
        dacFrequency = get(obj, 'dacFrequency');
        
        % Convert the waveform to the range for the driver
        arbitraryWave = int16(arbitraryWaveform * double(intmax('int16')));
        
        startFrequency = get(obj, 'startFrequency');

        startDeltaPhase = freq2delta(startFrequency, length(arbitraryWave), ...
            maxBufferSize, dacFrequency);

        stopDeltaPhase = 0;

        dwellCount = 0;

        % No need to calculate stop delta phase if start and stop frequencies
        % are the same.
        
        stopFrequency = get(obj, 'stopFrequency');
        
        if(stopFrequency == startFrequency)

            stopDeltaPhase = startDeltaPhase;

        else

            stopDeltaPhase = freq2delta(stopFrequency, length(arbitraryWave), ...
                maxBufferSize, dacFrequency);

        end
        
        deltaPhaseIncrement = freq2delta(increment, length(arbitraryWave), ...
                maxBufferSize, dacFrequency);
            
        dwellCount = round(dwellTime * dacFrequency); % Round to the nearest integer
        
        if(dwellCount &lt; PS4000aConstants.PS4000A_MIN_DWELL_COUNT)

            dwellCount = PS4000aConstants.PS4000A_MIN_DWELL_COUNT;

        end
        
        % Return dwell time information to the user if it has been
        % modified.
        dwellTime = dwellCount / dacFrequency;

        % No external trigger for PicoScope 4824
        extInThreshold = 0;

        status = calllib('ps4000a', 'ps4000aSetSigGenPropertiesArbitrary', ...
                    deviceObj.DriverData.unitHandle, startDeltaPhase, ...
                    stopDeltaPhase, deltaPhaseIncrement, dwellCount, ...
                    sweepType, shots, sweeps, triggerType, triggerSource, ...
                    extInThreshold);
         
        % Output error message to user if status is not PICO_OK        
        if(status ~= PicoStatus.PICO_OK)
                    
            switch(status)

                case PicoStatus.PICO_SIG_GEN_PARAM
                    
                    error('setSigGenArbitrary: Incorrect parameter passed to the signal generator.');
                    
                case PicoStatus.PICO_SHOTS_SWEEPS_WARNING
                    
                    error('setSigGenArbitrary: Incorrect parameter passed to the signal generator.');
                    
                otherwise     
                    
                    error('setSigGenArbitrary:- Status code: %d. Please refer to the PicoStatus.m file.', status);
            end
            
        end

        clear maxBufferSize
        clear dacFrequency
        clear startDeltaPhase
        clear stopDeltaPhase
        clear dwellCount
        clear deltaPhaseIncrement
        clear startFrequency;
        clear stopFrequency;
                
    else
       
        error('AWG functionality not supported by this device.');
        
    end</MCode>
               </Code>
               <Description>setSigGenArbitrary(obj, increment, dwellTime, sweepType, shots, sweeps, triggerType, triggerSource, extInThreshold) reprograms the arbitrary waveform generator. 

All values can be reprogrammed while the signal generator is waiting for a trigger.

The startFrequency, stopFrequency, offsetVoltage and peakToPeakVoltage properties must be set prior to calling this function, otherwise the default values will be used.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Signalgenerator group.
increment - the increase or decrease in frequency when operating in sweep mode.
dwellTime - the time for which the sweep stays at each frequency, in seconds.
sweepType -  determines whether the startFrequency is swept up to the stopFrequency, or down to it, or repeatedly up and down.
shots - the number of cycles of the waveform to be produced after a trigger event. If this is set to a non-zero value 
		then sweeps must be set to zero.
sweeps - the number of times to sweep the frequency after a trigger event, according to sweepType. If this is set to a non-zero value 
		then shots must be set to zero.
triggerType - the type of trigger that will be applied to the signal generator.
triggerSource - the source that will trigger the signal generator.
extInThresholdMV - not used by the PicoScope 4824

Output parameters:

status - the status code returned by the driver.
dwellTime -  the dwell time will be modified if the user specifies a dwell time (125e-9) corresponding to less than the minimum dwell count for the device (10).

For further information on the ps4000aSetSigGenPropertiesArbitrary function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes.
</Description>
            </Method>
            <Method>
               <Name>setSigGenPropertiesBuiltIn</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setSigGenPropertiesBuiltIn(obj, increment, dwellTime, sweepType, shots, sweeps, triggerType, triggerSource, extInThresholdMV)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    sigGenType = get(obj, 'sigGenType');
    
    % Error checking
    if(sigGenType == PicoConstants.SIG_GEN_AWG || ...
            sigGenType == PicoConstants.SIG_GEN_FUNCT_GEN)
        
        % External trigger not used
        extInThreshold = 0;

        status = calllib('ps4000a', 'ps4000aSetSigGenPropertiesBuiltIn', ...
                    deviceObj.DriverData.unitHandle, ...
                    deviceObj.DriverData.startFrequency, 
                    deviceObj.DriverData.stopFrequency, ...
                    increment, dwellTime, sweepType, shots, sweeps, ...
                    triggerType, triggerSource, extInThreshold);

        % Output error message to user if status is not PICO_OK        
        if(status ~= PicoStatus.PICO_OK)

            switch(status)

                case PicoStatus.PICO_SIG_GEN_PARAM

                    error('setSigGenPropertiesBuiltIn: One or more signal generator parameters are out of range.');

                case PicoStatus.PICO_SHOTS_SWEEPS_WARNING

                    error('setSigGenPropertiesBuiltIn: Shots/sweeps warning.');

                otherwise     

                    error('setSigGenPropertiesBuiltIn:- Status code: %d. Please refer to the PicoStatus.m file.', status);
            end

        end
        
        clear sigGenType;
            
    else
        
        error('setSigGenPropertiesBuiltIn: Signal Generator functionality not supported by this device.');
        
    end
    </MCode>
               </Code>
               <Description>setSigGenPropertiesBuiltIn(obj, increment, dwellTime, sweepType, shots, sweeps, triggerType, triggerSource, extInThresholdMV) reprograms the signal generator. 

Values can be changed while the signal generator is waiting for a trigger.

The startFrequency, stopFrequency, offsetVoltage and peakToPeakVoltage properties must be set prior to calling this function or the default values will be used.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Signalgenerator group.
increment - the amount in hertz by which the frequency rises or falls every dwellTime seconds in sweep mode.
dwellTime - the time in seconds between frequency changes in sweep mode.
sweepType - determines whether the startFrequency is swept up to the stopFrequency, or down to it, or repeatedly up and down.
shots - the number of cycles of the waveform to be produced after a trigger event. If this is set to a non-zero value 
		then sweeps must be set to zero.
sweeps - the number of times to sweep the frequency after a trigger event, according to sweepType. If this is set to a non-zero value 
		then shots must be set to zero.
triggerType - the type of trigger that will be applied to the signal generator.
triggerSource - the source that will trigger the signal generator.
extInThresholdMV - not used by the PicoScope 4824

Output parameters:

status - the status code returned by the driver.

For further information on the ps4000aSetSigGenPropertiesBuiltIn function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>streaming</Name>
         <Description>The Streaming group contains a set of properties and functions related to the streaming data collection functionality of the device.</Description>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="streaming" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>autoStop</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.autoStop;
</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    deviceObj.DriverData.autoStop = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>1</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>A flag to specify if streaming data collection should stop when all of maxSamples have been taken.

This flag should be set to 0 (collect streaming data continously) or 1 (stop after all required samples have been collected).</Description>
            </Property>
            <Property>
               <Name>streamingInterval</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.streamingInterval;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    deviceObj.DriverData.streamingInterval = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="4.294967295E9" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>1e-6</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The desired sampling interval for streaming mode data collection, in seconds.</Description>
            </Property>
         </PropertyInfo>
         <MethodInfo>
            <Method>
               <Name>autoStopped</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function autoStop = autoStopped(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    unitHandle = deviceObj.DriverData.unitHandle;
    
    autoStop = calllib('ps4000aWrap', 'AutoStopped', unitHandle);</MCode>
               </Code>
               <Description>AutoStopped(obj) indicates if the device has stopped on collection of the number of samples specified in the call to the ps4000aRunStreaming function.

The autoStop property must have been set to 1.

Input parameters:

obj - the object representing the Streaming group.

Output parameters:

autoStop - 0 if the device has not stopped, non-zero if streaming has auto-stopped.</Description>
            </Method>
            <Method>
               <Name>availableData</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [numSamples, startIndex] = availableData(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    unitHandle = deviceObj.DriverData.unitHandle;
    
    startIndex = 0; % Initialise variable to be used as a pointer

    [numSamples, startIndex] = calllib('ps4000aWrap', 'AvailableData', ...
                                unitHandle, startIndex);</MCode>
               </Code>
               <Description>availableData(obj) indicates the number of samples returned from the driver and shows the start index of the data in the buffer when collecting data in streaming mode.

Input parameters:

obj - the object representing the Streaming group.

Output parameters:

numSamples - 0, data is not yet available; Non-zero, the number of samples returned from the driver.
startIndex - an index to the first valid sample in the buffer (when data is available).

Note: the startIndex value is zero-based so should be incremented by 1 when used to retrieve data from the buffer.</Description>
            </Method>
            <Method>
               <Name>clearTriggerReady</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function triggerCleared = clearTriggerReady(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    unitHandle = deviceObj.DriverData.unitHandle;
    
    triggerCleared = calllib('ps4000aWrap', 'ClearTriggerReady', unitHandle);</MCode>
               </Code>
               <Description>clearTriggerReady(obj) clears the triggered and triggeredAt flags in relation to streaming mode capture.

Input parameters:

obj - the object representing the Streaming group.

Output parameters:

1 - Call successfully completed.</Description>
            </Method>
            <Method>
               <Name>getStreamingLatestValues</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = getStreamingLatestValues(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    unitHandle = deviceObj.DriverData.unitHandle;
    
    status = calllib('ps4000aWrap', 'GetStreamingLatestValues', ...
                unitHandle);
            
    if(status ~= PicoStatus.PICO_OK &amp;&amp; status ~= PicoStatus.PICO_BUSY)
           
        error('ps4000aGetStreamingLatestValues:- Status code: %d. Please refer to the PicoStatus.m file.', status); 
        
    end</MCode>
               </Code>
               <Description>getStreamingLatestValues(obj) facilitates communication with the underlying driver to return the next block of values to your application when capturing data in streaming mode.

Input parameters:

obj - the object representing the Streaming group.

Output parameters:

status - the status code returned by the driver.

For further information on the underlying ps4000aGetStreamingLatestValues function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>isReady</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function ready = isReady(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    unitHandle = deviceObj.DriverData.unitHandle;
    
    ready = calllib('ps4000aWrap', 'IsReady', unitHandle);
</MCode>
               </Code>
               <Description>isReady(obj) is used to poll the driver to verify that data is ready to be received. The ps4000aRunStreaming function must have been called prior to calling this function.

Input parameters:

obj - the object representing the Streaming group.

Output parameters:

ready - 0, if data is not yet available; non-zero if data is ready to be collected.</Description>
            </Method>
            <Method>
               <Name>isTriggerReady</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [triggered, triggeredAt] = isTriggerReady(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    unitHandle = deviceObj.DriverData.unitHandle;
    
    triggeredAt = 0; % Initialise value to zero for pointer.

    [triggered, triggeredAt] = calllib('ps4000aWrap', 'IsTriggerReady', ...
        unitHandle, triggeredAt);
</MCode>
               </Code>
               <Description>isTriggerReady(obj) indicates whether a trigger has occurred when collecting data in streaming mode, and the location of the trigger point.

Input parameters:

obj - the object representing the Streaming group.

Output parameters:

triggered - 0, if the device has not triggered; Non-zero, if the device has been triggered.
triggeredAt - the zero-based index of the sample in the buffer where the trigger occurred.</Description>
            </Method>
            <Method>
               <Name>ps4000aNoOfStreamingValues</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, noOfValues] = ps4000aNoOfStreamingValues(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    unitHandle = deviceObj.DriverData.unitHandle;
    
    noOfValues = 0; % Initialise value for use as pointer.

    [status, noOfValues] = calllib('ps4000a', 'ps4000aNoOfStreamingValues', ...
        unitHandle, noOfValues);
    
    if(status ~= PicoStatus.PICO_OK)
           
        error('ps4000aNoOfStreamingValues:- Status code: %d. Please refer to the PicoStatus.m file.', status); 
        
    end
</MCode>
               </Code>
               <Description>ps4000aNoOfStreamingValues(obj) returns the number of samples available after data collection in streaming mode. Call this function after calling ps4000aStop.

Input parameters:

obj - the object representing the device.

Output parameters:

status - status code returned by the driver.
noOfValues - the number of samples.

For further information on the ps4000aNoOfStreamingValues function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps4000aRunStreaming</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, sampleInterval, sampleIntervalTimeUnitsStr] = ps4000aRunStreaming(obj, downSampleRatio, downSampleRatioMode, overviewBufferSize)


    deviceObj = get(obj, 'Parent');
    unitHandle = deviceObj.DriverData.unitHandle;
    
    % Calculate sampleInterval and sampleIntervalTimeUnits according to
    % streamingInterval property set. Property is defined in seconds.

    streamingInterval = deviceObj.DriverData.streamingInterval;
    
    femtosecondsEnum    = deviceObj.DriverData.enums.enPS4000ATimeUnits.PS4000A_FS;
    picosecondsEnum     = deviceObj.DriverData.enums.enPS4000ATimeUnits.PS4000A_PS;
    nanosecondsEnum     = deviceObj.DriverData.enums.enPS4000ATimeUnits.PS4000A_NS;
    microsecondsEnum    = deviceObj.DriverData.enums.enPS4000ATimeUnits.PS4000A_US;
    millisecondsEnum    = deviceObj.DriverData.enums.enPS4000ATimeUnits.PS4000A_MS;
    secondsEnum         = deviceObj.DriverData.enums.enPS4000ATimeUnits.PS4000A_S;
    
    sampleIntervalTimeUnits = secondsEnum;
    
    % Match the specified interval to the correct time units
    % If an interval with component less than the minimum value for the time unit 
    % is specified e.g 1.3e-3, that will be converted to 1300 microseconds.
    
    if(streamingInterval &lt; 1e-12) % Femtoseconds (unlikely with USB 2.0/USB 3.0)
        
        sampleInterval = streamingInterval * 1e15;
        sampleIntervalTimeUnits = femtosecondsEnum;
        
    elseif(streamingInterval &gt;= 1e-12 &amp;&amp; streamingInterval &lt; 1e-9) % Picoseconds
        
        if(mod(streamingInterval, 1e-12) &gt; 0)
        
            sampleInterval = streamingInterval * 1e15;
            sampleIntervalTimeUnits = femtosecondsEnum;
            
        else
           
            sampleInterval = streamingInterval * 1e12;
            sampleIntervalTimeUnits = picosecondsEnum;
            
        end
        
	elseif(streamingInterval &gt;= 1e-9 &amp;&amp; streamingInterval &lt; 1e-6) % Nanoseconds

        if(mod(streamingInterval, 1e-9) &gt; 0)
            
            sampleInterval = streamingInterval * 1e12;
            sampleIntervalTimeUnits = picosecondsEnum;
            
        else
           
            sampleInterval = streamingInterval * 1e9;
            sampleIntervalTimeUnits = nanosecondsEnum;
            
        end
        
	elseif(streamingInterval &gt;= 1e-6 &amp;&amp; streamingInterval &lt; 1e-3) % Microseconds
        
        if(mod(streamingInterval, 1e-6) &gt; 0)
        
            sampleInterval = streamingInterval * 1e9;
            sampleIntervalTimeUnits = nanosecondsEnum;
            
        else
           
            sampleInterval = streamingInterval * 1e6;
            sampleIntervalTimeUnits = microsecondsEnum;
            
        end
        
    elseif(streamingInterval &gt;= 1e-3 &amp;&amp; streamingInterval &lt; 1) % Milliseconds
        
        if(mod(streamingInterval, 1e-3) &gt; 0)
           
            sampleInterval = streamingInterval * 1e6;
            sampleIntervalTimeUnits = microsecondsEnum;
            
        else
            
            sampleInterval = streamingInterval * 1e3;
            sampleIntervalTimeUnits = millisecondsEnum;
            
        end
            
    else 
        
        % Already defined seconds 
        
        % 
        if(mod(sampleInterval, 1) &gt; 0)
           
           sampleInterval = streamingInterval * 1e3;
           sampleIntervalTimeUnits = millisecondsEnum;
           
       end
        
    end
        
    autoStop = get(obj, 'autoStop');
    
    [status, sampleInterval] = calllib('ps4000a', 'ps4000aRunStreaming', ...
        unitHandle, sampleInterval, sampleIntervalTimeUnits, ...
        deviceObj.DriverData.numPreTriggerSamples, ...
        deviceObj.DriverData.numPostTriggerSamples, ...
        autoStop, downSampleRatio, downSampleRatioMode, overviewBufferSize);
    
    if(status == PicoStatus.PICO_OK)
           
        if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
            
            fprintf('ps4000aRunStreaming:- Sample interval %d', sampleInterval);
            
        end
        
        switch(sampleIntervalTimeUnits)
       
            case femtosecondsEnum

                sampleIntervalTimeUnitsStr = 'fs';
                
            case picosecondsEnum

                sampleIntervalTimeUnitsStr = 'ps';

            case nanosecondsEnum

                sampleIntervalTimeUnitsStr = 'ns';

            case microsecondsEnum

                sampleIntervalTimeUnitsStr = 'us';

            case millisecondsEnum

                sampleIntervalTimeUnitsStr = 'ms';

            case secondsEnum

                sampleIntervalTimeUnitsStr = 's';
            
            otherwise
                
                % Do nothing
        
        end
        
        if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
            
            fprintf(' %s\n', sampleIntervalTimeUnitsStr);
            
        end
        
        clear streamingInterval;
        clear femtosecondsEnum;
        clear picosecondsEnum;
        clear nanosecondsEnum;
        clear microsecondsEnum;
        clear millisecondsEnum;
        clear secondsEnum;
        
    % Check for Power connection
    elseif(status == PicoStatus.PICO_USB3_0_DEVICE_NON_USB3_0_PORT || ...
            status == PicoStatus.PICO_POWER_SUPPLY_NOT_CONNECTED)
    
        status = invoke(obj, 'ps4000aChangePowerSource', status)
        
    else
        
        error('ps4000aRunStreaming:- Status code: %d. Please refer to the PicoStatus.m file.', status);
        
    end
</MCode>
               </Code>
               <Description>ps4000aRunStreaming(obj, downSampleRatio, downSampleRatioMode, overviewBufferSize) function tells the oscilloscope to start collecting data in streaming mode. Use the function getStreamingLatestValues to ensure values are copied into the application buffers. 

Input parameters:

obj - the object representing the Streaming group.
downSampleRatio - the downsampling factor that will be applied to the raw data.
downSampleRatioMode -  which downsampling mode to use (an enumeration from the PS4000A_RATIO_MODE range).
overviewBufferSize - the size of the overview buffers (temporary buffers used for storing the data before returning it to the application).

Output parameters:

status - the status code returned by the driver.
sampleInterval - the actual time interval used.
sampleIntervalTimeUnitsStr - a string representing the time unit for the sampling interval.

For further information on the ps4000aRunStreaming function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>setAppAndDriverBuffers</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setAppAndDriverBuffers(obj, channel, appBuffer, driverBuffer, bufferLength)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    unitHandle = deviceObj.DriverData.unitHandle;
    
    status = calllib('ps4000aWrap', 'setAppAndDriverBuffers', ...
        unitHandle, channel, appBuffer, driverBuffer, bufferLength);
    
    if(status ~= PicoStatus.PICO_OK)
       
        if(status == PicoStatus.PICO_INVALID_CHANNEL)
            
            error('setAppAndDriverBuffers: Invalid channel specified.');
                    
        elseif(status == PICO_INVALID_HANDLE)
            
            error('setAppAndDriverBuffers: Invalid handle specified.');
            
        else
            
            error('setAppAndDriverBuffers:- Status code: %d. Please refer to the PicoStatus.m file.', status); 
        
        end
        
    end</MCode>
               </Code>
               <Description>setAppAndDriverBuffers(obj, channel, appBuffer, driverBuffer, bufferLength) set the application and corresponding driver buffer in the wrapper dll.

This function is required to allow the driver to copy the data into the application buffer being used in MATLAB when acquiring data from the PicoScope in streaming mode without aggregation.

Input parameters:

obj - the object representing the Streaming group.
channel - the channel to which the buffer corresponds (an enumeration from the PS4000A_CHANNEL range).
appBuffer - a libpointer to a 1-D array of 16-bit integer values representing the application buffer.
driverBuffer - the libpointer passed to the driver in the ps4000aSetDataBuffer function call.
bufferLength - the length of the arrays (must be equal)

Output parameters:

status - the status code returned by the wrapper driver.</Description>
            </Method>
            <Method>
               <Name>setMaxMinAppAndDriverBuffers</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setMaxMinAppAndDriverBuffers(obj, channel, appMaxBuffer, appMinBuffer, driverMaxBuffer, driverMinBuffer, bufferLength)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
    
    deviceObj = get(obj, 'Parent');
    unitHandle = deviceObj.DriverData.unitHandle;
    
    status = calllib('ps4000aWrap', 'setMaxMinAppAndDriverBuffers', ...
        unitHandle, channel, appMaxBuffer, appMinBuffer, ...
        driverMaxBuffer, driverMinBuffer, bufferLength);
    
    if(status ~= PicoStatus.PICO_OK)
       
        if(status == PicoStatus.PICO_INVALID_CHANNEL)
            
            error('setAppAndDriverBuffers: Invalid channel specified.');
                    
        elseif(status == PICO_INVALID_HANDLE)
            
            error('setMaxMinAppAndDriverBuffers: Invalid handle specified.');
            
        else
            
            error('setMaxMinAppAndDriverBuffers:- Status code: %d. Please refer to the PicoStatus.m file.', status); 
        
        end
        
    end</MCode>
               </Code>
               <Description>setAppAndDriverBuffers(obj, channel, appMaxBuffer, appMinBuffer, driverMaxBuffer, driverMinBuffer, bufferLength) set the maximum and minimum application and corresponding driver buffers in the wrapper dll.

This function is required to allow the driver to copy the data into the maximum and minimum application buffers being used in MATLAB when acquiring data from the PicoScope in 
streaming mode with aggregation.

Input parameters:

obj - the object representing the Streaming group.
channel - the channel to which the buffer corresponds (an enumeration from the PS4000A_CHANNEL range).
appMaxBuffer - a libpointer to a 1-D array of 16-bit integer values representing the application buffer.
appMinBuffer - a libpointer to a 1-D array of 16-bit integer values representing the application buffer.
driverMaxBuffer - the libpointer passed to the driver for the maximum aggregated data values  in the ps4000aSetDataBuffers function call.
driverMinBuffer - the libpointer passed to the driver for the minimum aggregated data values in the ps4000aSetDataBuffers function call.
bufferLength - the length of the arrays (must be equal)

Output parameters:

status - the status code returned by the wrapper driver.</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>trigger</Name>
         <Description>The Trigger group contains a set of properties and functions related to the trigger functionality of the device.</Description>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="trigger" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>autoTriggerMs</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
     % If autoTriggerMs doesn't exist, create it.
    if ( ~isfield(deviceObj.DriverData, 'autoTriggerMs') )
        deviceObj.DriverData.autoTriggerMs = 0;
    end
    
    propertyValue = deviceObj.DriverData.autoTriggerMs;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    deviceObj.DriverData.autoTriggerMs = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="32767.0" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The number of milliseconds the device will wait if no trigger occurs. 

Set to 0 in order for the device to wait indefinitely for a trigger event. 
</Description>
            </Property>
            <Property>
               <Name>delay</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
     % If delay doesn't exist, create it.
    if ( ~isfield(deviceObj.DriverData, 'delay') )
        deviceObj.DriverData.delay = 0;
    end
    
    propertyValue = deviceObj.DriverData.delay;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    deviceObj.DriverData.delay = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="4.294967295E9" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The time, in sample periods, between the trigger occurring and the first sample being taken.</Description>
            </Property>
         </PropertyInfo>
         <MethodInfo>
            <Method>
               <Name>ps4000aIsTriggerOrPulseWidthQualifierEnabled</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, triggerEnabled, pwqEnabled] = ps4000aIsTriggerOrPulseWidthQualifierEnabled(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    % Allocate values for variables
    triggerEnabled = 0;
    pwqEnabled = 0;

    [status, triggerEnabled, pwqEnabled] = calllib('ps4000a', ...
        'ps4000aIsTriggerOrPulseWidthQualifierEnabled', ...
        deviceObj.DriverData.unitHandle, triggerEnabled, pwqEnabled);

    if(status ~= PicoStatus.PICO_OK)

        error('ps4000aIsTriggerOrPulseWidthQualifierEnabled:- Status code: %d. Please refer to the PicoStatus.m file.', status); 

    end</MCode>
               </Code>
               <Description>ps4000aIsTriggerOrPulseWidthQualifierEnabled(obj) discovers whether a trigger, or pulse width triggering, is enabled.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Trigger group.

Output parameters:

status - the status code returned by the driver.
triggerEnabled - indicates if trigger is set.
pwqEnabled - indicates if pulse widtrh qualifier is set.

For further information on the ps4000aIsTriggerOrPulseWidthQualifierEnabled function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>setAdvancedTrigger</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function advTrigStatus = setAdvancedTrigger(obj, channelProperties, directions)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    auxOutputEnabled = 0;
    
    advTrigStatus = zeros(3, 1);
    
    % Set Advanced Trigger Properties
    advTrigStatus(1) = calllib('ps4000a', ...
        'ps4000aSetTriggerChannelProperties', deviceObj.DriverData.unitHandle, ...
        channelProperties, length(channelProperties), auxOutputEnabled, ...
        deviceObj.DriverData.autoTriggerMs);
    
    if(advTrigStatus(1) ~= PicoStatus.PICO_OK)

        error('ps4000aSetTriggerChannelProperties:- Status code: %d. Please refer to the PicoStatus.m file.', advTrigStatus(1)); 

    end

    % Set Advanced Trigger Properties
    advTrigStatus(2) = calllib('ps4000a', ...
        'ps4000aSetTriggerChannelDirections', ...
        deviceObj.DriverData.unitHandle, directions, length(directions));

    if(advTrigStatus(2) ~= PicoStatus.PICO_OK)

        error('ps4000aSetTriggerChannelDirections:- Status code: %d. Please refer to the PicoStatus.m file.', advTrigStatus(2)); 

    end
    
    % Set Advanced Trigger Delay
    advTrigStatus(3) = calllib('ps4000a', ...
        'ps4000aSetTriggerDelay', deviceObj.DriverData.unitHandle, ...
        deviceObj.DriverData.delay);
    
     if(advTrigStatus(3) ~= PicoStatus.PICO_OK)

        error('ps4000aSetTriggerDelay:- Status code: %d. Please refer to the PicoStatus.m file.', advTrigStatus(2)); 

    end</MCode>
               </Code>
               <Description>setAdvancedTrigger(obj, channelProperties, directions) sets the Advanced Trigger properties and channel directions for the oscilloscope.

Input parameters:

obj - the object representing the Trigger group.
channelProperties - an array of PS4000A_TRIGGER_CHANNEL_PROPERTIES (accessible via ps4000aStructs.tPS4000ATriggerChannelProperties) structures describing the requested properties.
directions - an array of structures (PS4000A_DIRECTION available via ps4000aStructs.tPS4000ADirection) containing trigger directions.

Output parameters:

advTrigStatus - a 3x1 array corresponding to the status codes returned by the ps4000aSetTriggerChannelProperties, ps4000aSetTriggerChannelDirections and ps4000aSetTriggerDelay functions.

For further information on the ps4000aSetTriggerChannelProperties, ps4000aSetTriggerChannelDirections and ps4000aSetTriggerDelay functions please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.
</Description>
            </Method>
            <Method>
               <Name>setPulseWidthQualifier</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function pwqStatus = setPulseWidthQualifier(obj, pwqConditions, info, direction, lower, upper, type)

    deviceObj = get(obj, 'Parent');

    pwqStatus = zeros(2, 1);
    
    % Set the PWQ channel conditions
    pwqStatus(1) = calllib('ps4000a', ...
        'ps4000aSetPulseWidthQualifierConditions', ...
        deviceObj.DriverData.unitHandle, ...
        pwqConditions, length(pwqConditions), info);
    
    if(pwqStatus(1) ~= PicoStatus.PICO_OK)

        error('ps4000aSetPulseWidthQualifierConditions:- Status code: %d. Please refer to the PicoStatus.m file.', pwqStatus(1)); 

    end

    % Set the PWQ properties
    pwqStatus(2) = calllib('ps4000a', ...
        'ps4000aSetPulseWidthQualifierProperties', ...
        deviceObj.DriverData.unitHandle, ...
        direction, lower, upper, type);
    
    if(pwqStatus(2) ~= PicoStatus.PICO_OK)

        error('ps4000aSetPulseWidthQualifierProperties:- Status code: %d. Please refer to the PicoStatus.m file.', pwqStatus(2)); 

    end</MCode>
               </Code>
               <Description>setPulseWidthQualifier(obj, pwqConditions, info, direction, lower, upper, type) sets up the conditions and properties for pulse width qualification on the oscilloscope.

Input parameters:

obj - the object representing the Trigger group.
triggerConditions - an array of PS4000A_CONDITION structures (available via ps4000aStructs.tPS4000ACondition) specifying the conditions that should be applied to each channel.
info - determines whether the function clears previous conditions:
	PS4000A_CLEAR (ps4000aEnuminfo.enPS4000AConditionsInfo.PS4000A_CLEAR), clears previous conditions
	PS4000A_ADD (ps4000aEnuminfo.enPS4000AConditionsInfo.PS4000A_ADD), adds the specified conditions (ORing them with previously set conditions, if any)
direction - the direction of the signal required for the trigger to fire (a PS4000A_DIRECTION enumeration available via ps4000aStruct.tPS4000ADirection) 
lower - the lower limit of the pulse width counter, in samples.
upper - the upper limit of the pulse width counter, in samples (only used for in range or out of range scenarios).
type - the pulse width type (an ps4000aEnuminfo.enPS4000APulseWidthType enumeration).

Output parameters:

pwqTrigStatus - a 2x1 array corresponding to the status codes returned by the calls to the ps4000aSetPulseWidthQualifierConditions and ps4000aSetPulseWidthQualifierProperties functions respectively.

For further information on the underlying ps4000aSetPulseWidthQualifierConditions and ps4000aPulseWidthQualifierProperties functions please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.
</Description>
            </Method>
            <Method>
               <Name>setSimpleTrigger</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setSimpleTrigger(obj, source, threshold, direction)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    % Find the voltage range index
    % Set default as 5V (External trigger will use this range).
    channelRange = deviceObj.DriverData.enums.enPS4000ARange.PS4000A_5V;

    % Obtain information for device 
    channelSettings = deviceObj.DriverData.channelSettings;
    
    % Range is item 3 in the row for each channel

    switch (source)

        % Channel A
        case deviceObj.DriverData.enums.enPS4000AChannel.PS4000A_CHANNEL_A

            channelRange = channelSettings(1,3);

        % Channel B
        case deviceObj.DriverData.enums.enPS4000AChannel.PS4000A_CHANNEL_B

            channelRange = channelSettings(2,3);

        % Channel C
        case deviceObj.DriverData.enums.enPS4000AChannel.PS4000A_CHANNEL_C

            channelRange = channelSettings(3,3);

        % Channel D
        case deviceObj.DriverData.enums.enPS4000AChannel.PS4000A_CHANNEL_D

            channelRange = channelSettings(4,3);
        
        % Channel E
        case deviceObj.DriverData.enums.enPS4000AChannel.PS4000A_CHANNEL_E

            channelRange = channelSettings(5,3);

        % Channel F
        case deviceObj.DriverData.enums.enPS4000AChannel.PS4000A_CHANNEL_F

            channelRange = channelSettings(6,3);

        % Channel G
        case deviceObj.DriverData.enums.enPS4000AChannel.PS4000A_CHANNEL_G

            channelRange = channelSettings(7,3);

        % Channel H
        case deviceObj.DriverData.enums.enPS4000AChannel.PS4000A_CHANNEL_H

            channelRange = channelSettings(8,3);
            
        % External trigger
        case deviceObj.DriverData.enums.enPS4000AChannel.PS4000A_EXTERNAL
            
            % External trigger has +/-5V range - no need to change.

        otherwise

            error('setSimpleTrigger: Invalid channel specified');

    end
    
    channelInputRange = 5000; % Default of +/- 5 V
    
    if (isequal(source, deviceObj.DriverData.enums.enPS4000AChannel.PS4000A_EXTERNAL))
        
        channelInputRange = PicoConstants.SCOPE_INPUT_RANGES(channelRange + 1);
        
    else
        
        % Obtain the channel input range for PicoConnect probes.
        [channelInputRange, ~] = invoke(deviceObj, 'getChannelInputRangeAndUnits', source);
        
    end
    
    % Calculate the threshold in ADC counts
    thresholdADC = mv2adc(threshold, channelInputRange, deviceObj.DriverData.maxADCValue);

    status = calllib('ps4000a', 'ps4000aSetSimpleTrigger', ...
            deviceObj.DriverData.unitHandle, PicoConstants.TRUE, source, ...
            thresholdADC, direction, deviceObj.DriverData.delay, ...
            deviceObj.DriverData.autoTriggerMs);
        
    if (status ~= PicoStatus.PICO_OK)
       
        error('setSimpleTrigger: Status code:- %d. Please refer to the PicoStatus.m file.', status);
        
    end
</MCode>
               </Code>
               <Description>setSimpleTrigger(obj, source, thresholdMV, direction) simplifies arming the trigger. 

It supports only the LEVEL trigger types and does not allow more than one channel to have a trigger applied to it.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Trigger group.
source - the channel on which to trigger.
threshold - the level at which the trigger will fire. For the PicoScope 4444, this will be either in millivolts, volts (1 kV high voltage probe) or amps. For other devices, this will be in millivolts.
direction - the direction in which the signal must move to cause a trigger.

Output parameters:

status - the status code returned by the driver.

For further information on the ps4000aSetSimpleTrigger function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>setTriggerChannelConditions</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setTriggerChannelConditions(obj, triggerConditions,info)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    status = calllib('ps4000a', ...
        'ps4000aSetTriggerChannelConditions', deviceObj.DriverData.unitHandle, ...
        triggerConditions, length(triggerConditions), info);
    
    if(status ~= PicoStatus.PICO_OK)

        error('ps4000aSetTriggerChannelConditions:- Status code: %d. Please refer to the PicoStatus.m file.', status); 

    end</MCode>
               </Code>
               <Description>setTriggerChannelConditions(obj,  triggerConditions, info) sets the Advanced Trigger Conditions for the oscilloscope.

Input parameters:

obj - the object representing the Trigger group.
triggerConditions - an array of PS4000A_CONDITION structures (available via ps4000aStructs.tPS4000ACondition) specifying the conditions that should be applied to each channel.
info - determines whether the function clears previous conditions:
	PS4000A_CLEAR (ps4000aEnuminfo.enPS4000AConditionsInfo.PS4000A_CLEAR), clears previous conditions
	PS4000A_ADD (ps4000aEnuminfo.enPS4000AConditionsInfo.PS4000A_ADD), adds the specified conditions (ORing them with previously set conditions, if any)

Output parameters:

status - the status code returned by the driver.

For further information on the underlying ps4000aSetTriggerChannelConditions function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>setTriggerOff</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setTriggerOff(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    % Set trigger to false for channel A
    
    source = deviceObj.DriverData.enums.enPS4000AChannel.PS4000A_CHANNEL_A;
    thresholdADC = 0;
    direction = deviceObj.DriverData.enums.enPS4000AThresholdDirection.PS4000A_RISING;
    
    status = calllib('ps4000a', 'ps4000aSetSimpleTrigger', ...
            deviceObj.DriverData.unitHandle, PicoConstants.FALSE, source, ...
            thresholdADC, direction, deviceObj.DriverData.delay, ...
            deviceObj.DriverData.autoTriggerMs);
    
    if (status ~= PicoStatus.PICO_OK)
           
        error('setTriggerOff: Status code:- %d. Please refer to the PicoStatus.m file.', status);
        
    end</MCode>
               </Code>
               <Description>setTriggerOff(obj) switches off triggering on the oscilloscope.

This function may be with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Trigger group.

Output parameters:

status - the status code returned by the driver.

For further information on the underlying ps4000aSetSimpleTrigger function please refer to the PicoScope 4000 Series (A API) PC Oscilloscopes Programmer's Guide.</Description>
            </Method>
         </MethodInfo>
      </Group>
   </GroupInfo>
</MATLABInstrumentDriver>